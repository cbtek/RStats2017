/*
    RStatsCSVWorkbookStream.cpp
    

*/
//----------------------------------------
//RStatsCSVWorkbookStream.cpp generated by cbtek on 04-01-2017 at 06:35:19 PM
//----------------------------------------
#include "RStatsCSVWorkbookStream.h"

#include "utility/inc/StringUtils.hpp"
#include "utility/inc/FileUtils.hpp"

#include <stack>
using namespace cbtek::common::utility;

namespace cbtek {
namespace rocketstats {
namespace utils {
namespace streams {

enum class RStatsCSVDataParseTypes
{
    Start,
    Empty,
    NotQuoted,
    Quoted
};

RStatsCSVWorkbookStream::RStatsCSVWorkbookStream(const std::string &filePath)
{
    m_filePath = filePath;
}

void RStatsCSVWorkbookStream::write(const RStatsWorkbook &workbook)
{
    if (workbook.getNumWorksheets() > 0)
    {
        FileUtils::writeFileContents(m_filePath,
                                     workbook(0).toCommaDelimitedString());
        if (workbook.getNumWorksheets() > 1)
        {
            std::cout << "WARNING: CSV does not support saving multiple sheets. Only the first sheet \"" <<workbook(0).getWorksheetTitle() << "\" will be saved." << std::endl;
        }
    }
}

RStatsWorkbook RStatsCSVWorkbookStream::read()
{
    RStatsWorkbook workbook;    
    std::ifstream in(m_filePath.c_str(), std::ios::in);
    size_t row = 0;
    RStatsWorksheet sheet;
    while (in)
    {
        std::string line;
        std::getline(in,line);
        StringUtils::trimmedInPlace(line);
        if (!in)
        {
            break;
        }

        readRow(line,sheet,row);
        ++row;
    }
    workbook.addWorksheet(sheet);
    return workbook;
}

RStatsCSVWorkbookStream::~RStatsCSVWorkbookStream()
{

}

void RStatsCSVWorkbookStream::readRow(const std::string &line,
                                      RStatsWorksheet &sheetOut,
                                      size_t currentRow)
{
    size_t index = 0;
    size_t currentColumn = 0;
    bool valid = true;
    while (valid)
    {
         valid = readCell(line,index,sheetOut(currentRow,currentColumn).text);
         sheetOut(currentRow,currentColumn).text = StringUtils::getFormattedNumeric(sheetOut(currentRow,currentColumn).text);
         if (!valid)
         {
             break;
         }
        ++currentColumn;
    }
}

bool RStatsCSVWorkbookStream::readCell(const std::string &line,
                                       size_t &startIndex,
                                       std::string &dataOut)
{
    RStatsCSVDataParseTypes type = RStatsCSVDataParseTypes::Start;
    size_t quoteCount = 0;

    //This boolean flag is used for helping know when
    //the data stream starts so that the ParseType
    //can be set.
    bool start = true;

    for (size_t a1 = startIndex; a1 < line.size(); ++a1)
    {
        char token = line[a1];
        if (start && token == '\"')
        {
            type = RStatsCSVDataParseTypes::Quoted;
            quoteCount++;
            start = false;
            continue;
        }
        else if(start)
        {
            type = RStatsCSVDataParseTypes::NotQuoted;
            start = false;
        }

        if (type == RStatsCSVDataParseTypes::Quoted)
        {
            //If we encounter a quote while in "Quoted" mode
            //then this must quote must be part of the cell
            //data.  Keep counting the number of quotes in
            //the cell data.  When a comma is reached if the
            //number of quotes counted is divisible by 2 then
            //the end of the cell data has been reached. Other
            //wise the comma is also part of the cell data.
            if (token == '\"')
            {
                quoteCount++;

                //Check for closing quote in cell data when
                //comma is discovered.  If this is the closing
                //quote then we can return false to go to the next
                //row in the file.  Also we have to convert the
                // [""]'s to ["]'s in the dataOut string
                if (a1 == line.size() - 1 && quoteCount % 2 == 0)
                {
                    startIndex = 0;
                    StringUtils::replaceInPlace(dataOut,"\"\"","\"");
                    return false;
                }
                dataOut.push_back(token);
            }

            else if (token == ',')
            {
                //Check for closing quote in cell data when
                //comma is discovere.  If this is the closing
                //quote then we can return true to continue
                //reading cells from this row
                if (quoteCount % 2 == 0)
                {
                    startIndex = a1 + 1;
                    parseLastCellOnRow(dataOut);
                    return true;
                }
                else
                {
                    dataOut.push_back(token);
                }
            }
            else
            {
                dataOut.push_back(token);
            }
        }
        else
        {
            //When comma is discovered for non-quoted data
            //then we can update the start index and continue
            //reading the next cell data on the row
            if (token == ',')
            {
                startIndex = a1 + 1;
                return true;
            }
            dataOut.push_back(token);
        }
    }

    //When end of line occurs before reading a comma
    //lets just return false and continue reading next
    //row from file.
    return false;

}

void RStatsCSVWorkbookStream::parseLastCellOnRow(std::string& dataOut)
{
    //So we had to add the last quote to the
    //dataOut field to read the comma seperator.
    //The code below removes that last quote.
    int dataOutSize = static_cast<int>(dataOut.size());
    for (int a2 = dataOutSize - 1; a2 >= 0; --a2)
    {
        size_t index = static_cast<size_t>(a2);
        if (dataOut[index] == ' ')
        {
            continue;
        }
        if (dataOut[index] == '\"')
        {
            dataOut.erase(dataOut.begin()+a2);
            StringUtils::replaceInPlace(dataOut,"\"\"","\"");
            return;
        }
    }
}




}}}}//end namespace


