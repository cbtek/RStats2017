/*
    UIRStatsMain.cpp
    

*/
//UIRStatsMain.cpp generated by CBTek Solutions on 02-03-2017 at 12:29:37 AM

#include <QDebug>
#include <QIcon>
#include <QGroupBox>
#include <QPushButton>
#include <QScrollArea>
#include <QFontMetrics>
#include <QLabel>
#include <QProcess>
#include <QMessageBox>
#include <QKeySequence>
#include <QTableWidgetItem>
#include <QPainter>
#include <QFontDatabase>
#include <QDesktopServices>

#include "UIRStatsMain.h"
#include "ui_UIRStatsMain.h"

#include "utility/inc/XMLUtils.h"
#include "utility/inc/FileUtils.hpp"
#include "utility/inc/SystemUtils.hpp"

#include "rstats_utils/inc/RStatsModuleProperties.h"
#include "rstats_utils/inc/RStatsUtils.hpp"
#include "rstats_utils/inc/RStatsWorkbook.h"

#include "rstats_ui/inc/UIRStatsAbout.h"
#include "rstats_ui/inc/UIRStatsErrorMessage.h"
#include "rstats_ui/inc/UIRStatsLaunchConfigDialog.h"
#include "rstats_ui/inc/UIRStatsSettingsManager.h"
#include "rstats_ui/inc/UIRStatsUtils.hpp"

using namespace cbtek::common::utility;
using namespace cbtek::rocketstats::ui;
using namespace cbtek::rocketstats::utils;

namespace cbtek {
namespace rocketstats {
namespace main {

UIRStatsMain::UIRStatsMain(QWidget *parent) :
    QMainWindow(parent),
    m_ui(new Ui_UIRStatsMain)
{        
    m_ui->setupUi(this);

    //Create module table and add to layout
    m_tblModules = new UIRStatsTablePreviewWidget;
    m_tblModules->setSelectionMode(QAbstractItemView::SingleSelection);
    m_ui->m_lytModules->addWidget(m_tblModules);

    //Set default labels for category list and module list
    onUpdateTableHeader(false);
    m_ui->m_lstModuleCategories->setFocus();


    //Set header labels color/style
    m_ui->m_lblModuleCategoryHeader->setStyleSheet("QLabel{padding:4px; border:1px solid gray;background:#BBFFBB;color:black;}");
    m_ui->m_lblModuleHeader->setStyleSheet("QLabel{padding:4px; border:1px solid gray;background:#FFFFFF;color:black;}");

    //Set images for all icons
    m_iconFolder = UIRStatsUtils::getIcon("img_folder.png");
    m_iconModule = UIRStatsUtils::getIcon("img_module.png");
    m_iconEdit = UIRStatsUtils::getIcon("img_edit.png");    
    m_iconAdd = UIRStatsUtils::getIcon("img_add.png");            
    m_iconRemove = UIRStatsUtils::getIcon("img_remove.png");
    m_iconOk = UIRStatsUtils::getIcon("img_ok.png");
    m_iconError = UIRStatsUtils::getIcon("img_error.png");
    m_iconRun = UIRStatsUtils::getIcon("img_run.png");
    this->setWindowIcon(UIRStatsUtils::getIcon("img_logo_icon.png"));
    //Set icons to actions/buttons
    UIRStatsUtils::initAction(m_ui->m_actionSettings_Manager,"img_settings.png","Alt+S");
    UIRStatsUtils::initAction(m_ui->m_actionExit,"img_exit.png","Alt+Q");
    UIRStatsUtils::initAction(m_ui->m_actionAbout_RAT_STATS_2017,"img_about.png","Alt+A");
    UIRStatsUtils::initAction(m_ui->m_actionHelp_Topics,"img_help.png","Alt+H");
    UIRStatsUtils::initAction(m_ui->m_actionAdd_New_Module,"img_add.png","Alt+N");

    //Set default values
    m_buttonHeight = 40;    
    m_tableHasFocus = false;
    m_ui->m_lstModuleCategories->setStyleSheet("QListWidget:item{height:"+QString::number(m_buttonHeight-8)+"px;}");
    m_ui->m_lstModuleCategories->setIconSize(QSize(m_buttonHeight-16,m_buttonHeight-16));
    onInitialize(0);

    QList<int> sizes;
    sizes << 200 << (600);
    m_ui->m_splMain->setSizes(sizes);
    //Create SIGNAL/SLOT connections for all actions/buttons and other widgets
    connect(m_ui->m_actionExit,SIGNAL(triggered(bool)),this,SLOT(onExit()));
    connect(m_ui->m_actionHelp_Topics,SIGNAL(triggered(bool)),this,SLOT(onLaunchHelp()));
    connect(m_ui->m_actionSettings_Manager,SIGNAL(triggered(bool)),this,SLOT(onLaunchSettingsManager()));
    connect(m_ui->m_actionAbout_RAT_STATS_2017,SIGNAL(triggered(bool)),this,SLOT(onLaunchAbout()));
    connect(m_ui->m_actionAdd_New_Module,SIGNAL(triggered(bool)),this,SLOT(onAddNewModule()));    
    connect(m_ui->m_lstModuleCategories,SIGNAL(currentRowChanged(int)),this,SLOT(onCategoryChanged(int)));
    connect(m_tblModules,SIGNAL(itemActivated(QTableWidgetItem*)),this,SLOT(onModuleCellActivated(QTableWidgetItem*)));

}

void UIRStatsMain::onRepopulateModules(const std::vector<RStatsModuleProperties>& propsIn)
{
    //Keeps track of current row in table
    int row = 0;

    //Reset the table widget
    m_tblModules->clear();
    m_tblModules->setRowCount(propsIn.size());
    m_tblModules->setColumnCount(3);
    m_tblModules->setHorizontalHeaderLabels(QStringList() << "Launch" << "Edit" << "Remove");
    m_tblModules->verticalHeader()->hide();
    m_tblModules->horizontalHeader()->hide();

    //Remove existing shortcuts
    for (size_t a1 = 0; a1 < m_shortcuts.size();++a1)
    {
        delete m_shortcuts[a1];
    }
    m_shortcuts.clear();

    //Loop over all module properties
    for(auto props : propsIn)
    {
        //Create cell item for module launch, edit and removal
        QTableWidgetItem * moduleChildLaunch = new QTableWidgetItem;
        QTableWidgetItem * moduleChildEdit = new QTableWidgetItem;
        QTableWidgetItem * moduleChildRemove = new QTableWidgetItem;

        //Check if module should be disabled
        bool isDisabled = !RStatsUtils::isValidModule(props.getPath());

        //Get path to xml config for module
        QString path = QString::fromStdString(props.getConfigPath());

        //Setup shortcut key for module and edit/remove/launch buttons
        QString removeKeyString,editKeyString,launchKeyString;
        QKeySequence editKey = this->getKeyEditSequence(row, editKeyString);
        QKeySequence removeKey = this->getKeyRemoveSequence(row, removeKeyString);
        QKeySequence launchKey = this->getKeyLaunchSequence(row, launchKeyString);
        UIRStatsShortcut * editShortcut = new UIRStatsShortcut(editKey,m_tblModules);
        UIRStatsShortcut * removeShortcut = new UIRStatsShortcut(removeKey,m_tblModules);
        UIRStatsShortcut * launchShortcut = new UIRStatsShortcut(launchKey,m_tblModules);

        editShortcut->setProperty("index",row);
        removeShortcut->setProperty("index",row);
        launchShortcut->setProperty("index",row);
        editShortcut->setProperty("path",path);
        removeShortcut->setProperty("path",path);
        launchShortcut->setProperty("path",path);

        m_shortcuts.push_back(editShortcut);
        m_shortcuts.push_back(removeShortcut);
        m_shortcuts.push_back(launchShortcut);

        //Set text/icon for module launch, edit and removal
        moduleChildLaunch->setText(QString::fromStdString(props.getName())+" (" + launchKeyString + ")");
        moduleChildEdit->setText("Edit (" + editKeyString + ")");
        moduleChildRemove->setText("Delete ("+removeKeyString + ")");
        moduleChildEdit->setIcon(m_iconEdit);
        moduleChildRemove->setIcon(m_iconRemove);
        moduleChildLaunch->setFlags(Qt::ItemIsSelectable | Qt::ItemIsEnabled);
        moduleChildEdit->setFlags(Qt::ItemIsSelectable | Qt::ItemIsEnabled);
        moduleChildRemove->setFlags(Qt::ItemIsSelectable | Qt::ItemIsEnabled);

        //If module is disabled then make each cell look disabled
        if (isDisabled)
        {
            moduleChildLaunch->setIcon(m_iconError);
        }
        else
        {
            moduleChildLaunch->setIcon(UIRStatsUtils::getIcon(props.getIcon()));
        }

        //Add the module launch, edit, removal cells to the table
        m_tblModules->setItem(row, 0, moduleChildLaunch);
        m_tblModules->setItem(row, 1, moduleChildEdit);
        m_tblModules->setItem(row, 2, moduleChildRemove);
        m_tblModules->setRowHeight(row, m_buttonHeight - 8);

        //Connect signal to slots for editing, removing and launching a module via shortcut
        connect(editShortcut,SIGNAL(activated(QShortcut*)),this,SLOT(onEditModuleShortcut(QShortcut*)));
        connect(removeShortcut,SIGNAL(activated(QShortcut*)),this,SLOT(onRemoveModuleShortcut(QShortcut*)));
        connect(launchShortcut,SIGNAL(activated(QShortcut*)),this,SLOT(onLaunchModuleShortcut(QShortcut*)));
        ++row;
    }

    //Resize all table columns to contents
    m_tblModules->horizontalHeader()->setSectionResizeMode(QHeaderView::ResizeToContents);

    //Expand the first column
    m_tblModules->horizontalHeader()->setSectionResizeMode(0,QHeaderView::Stretch);

}

UIRStatsMain::~UIRStatsMain()
{
    delete m_ui;
}

void UIRStatsMain::onInitialize(int defaultCategoryIndex)
{    

    //Clear modules
    m_ui->m_lstModuleCategories->clear();
    m_groupedModules.clear();

    //Grab the modules
    std::vector<RStatsModuleProperties> propsList;
    try
    {
         propsList = RStatsUtils::getModulePropertiesList();
    }
    catch (...)
    {
        RStatsUtils::createValidPath("config/.rstats_module_properties");
        RStatsUtils::createValidPath("config/.rstats_script_provider_properties");
        UIRStatsErrorMessage("No modules detected", "You have no modules available to launch.\nYou may create modules by pressing [Alt + N] or by clicking the \"Create new Module\" link in the file menu").exec();
        return;
    }

    //Loop over modules and determine which groups they belong to    
    for(const RStatsModuleProperties& props : propsList)
    {
        std::string category = props.getCategory();
        if (StringUtils::trimmed(category).size()==0)
        {
            category = "Uncategorized";
        }        
        m_groupedModules[category].push_back(props);
    }

    m_tblModules->setIconSize(QSize(m_buttonHeight-16,m_buttonHeight-16));

    //Lets loop over all modules by group and populate the module tables
    size_t tableIndex = 0;        
    for (const auto& it : m_groupedModules)
    {
        //Initialize button groups and table to hold module items
        QString name = QString::fromStdString(it.first);                                
        QListWidgetItem * moduleParent = new QListWidgetItem;
        moduleParent->setText(name);                        
        m_ui->m_lstModuleCategories->addItem(moduleParent);
        moduleParent->setIcon(m_iconFolder);
        ++tableIndex;        
    }
    if (defaultCategoryIndex < m_ui->m_lstModuleCategories->count())
    {
        QListWidgetItem * item = m_ui->m_lstModuleCategories->item(defaultCategoryIndex);

        if (item)
        {            
            m_ui->m_lstModuleCategories->setCurrentItem(item);
        }

    }
    onRepopulateModules(m_groupedModules[m_ui->m_lstModuleCategories->currentItem()->text().toStdString()]);
}


QString UIRStatsMain::getKeyAssignment(int count, bool isLaunch, bool isEdit, bool isRemove) const
{

    //Setup unique shortcut for up to 288 modules
    if (isLaunch)
    {
        QString keyString;
        if (count < 36)
        {
            keyString = "Ctrl";
        }
        else if (count >= 36 && count < 72)
        {
            count-=36;
            keyString = "Ctrl+Alt";
        }

        else if (count >= 72 && count < 108)
        {
            count-=72;
            keyString = "Ctrl+Shift";
        }

        else if (count >= 108 && count < 144)
        {
            count-=108;
            keyString = "Ctrl+Shift+Alt";

        }
        else if (count >= 144 && count < 180)
        {
            count-=144;
            keyString = "Ctrl+Alt+Shift";
        }        
        if (count < 9)
        {
             keyString+= "+"+QString::fromStdString(std::to_string((count+1)));
        }
        else
        {
            std::string label = RStatsUtils::getColumnLabelFromIndex(static_cast<size_t>(count-9));
            keyString+= "+"+QString::fromStdString(label);
        }
        return keyString;
    }
    else if (isEdit)
    {
        QString keyString;
        if (count < 36)
        {
            keyString = "Shift";
        }
        else if (count >= 36 && count < 72)
        {
            count-=36;
            keyString = "Shift+Ctrl";
        }

        else if (count >= 72 && count < 108)
        {
            count-=72;
            keyString = "Shift+Alt";
        }

        else if (count >= 108 && count < 144)
        {
            count-=108;
            keyString = "Shift+Ctrl+Alt";

        }
        else if (count >= 144 && count < 180)
        {
            count-=144;
            keyString = "Shift+Alt+Ctrl";
        }        
        if (count < 9)
        {
             keyString+= "+"+QString::fromStdString(std::to_string((count+1)));
        }
        else
        {
            std::string label = RStatsUtils::getColumnLabelFromIndex(static_cast<size_t>(count-9));
            keyString+= "+"+QString::fromStdString(label);
        }
        return keyString;
    }
    else if (isRemove)
    {
        QString keyString;
        if (count < 36)
        {
            keyString = "Alt";
        }
        else if (count >= 36 && count < 72)
        {
            count-=36;
            keyString = "Alt+Ctrl";
        }

        else if (count >= 72 && count < 108)
        {
            count-=72;
            keyString = "Alt+Shift";
        }

        else if (count >= 108 && count < 144)
        {
            count-=108;
            keyString = "Alt+Ctrl+Shift";

        }
        else if (count >= 144 && count < 180)
        {
            count-=144;
            keyString = "Alt+Shift+Ctrl";
        }
        if (count < 9)
        {
             keyString+= "+"+QString::fromStdString(std::to_string((count+1)));
        }
        else
        {
            std::string label = RStatsUtils::getColumnLabelFromIndex(static_cast<size_t>(count-9));
            keyString+= "+"+QString::fromStdString(label);
        }
        return keyString;
    }
    return "";
}

QKeySequence UIRStatsMain::getKeyLaunchSequence(int count, QString & keyString) const
{
    keyString = getKeyAssignment(count);
    return QKeySequence(keyString);
}

QKeySequence UIRStatsMain::getKeyEditSequence(int count, QString & keyString) const
{
    keyString = getKeyAssignment(count,false,true,false);
    return QKeySequence(keyString);
}

QKeySequence UIRStatsMain::getKeyRemoveSequence(int count, QString & keyString) const
{
    keyString = getKeyAssignment(count,false,false,true);
    return QKeySequence(keyString);
}

void UIRStatsMain::onExit()
{
    this->close();
}

void UIRStatsMain::onLaunchSettingsManager()
{
    UIRStatsSettingsManager().exec();
}

void UIRStatsMain::onLaunchAbout()
{
    UIRStatsAbout().exec();
}

void UIRStatsMain::onLaunchHelp()
{
    UIRStatsUtils::launchHelp("rstats.pdf");
}

void UIRStatsMain::onAddNewModule()
{
    try
    {
        utils::RStatsModuleProperties props;
        std::string path = FileUtils::buildFilePath(RStatsUtils::getModulePropertiesPath(),"module_"+DateTimeUtils::getTimeStamp()+".xml");
        props.setConfigPath(path);
        QListWidgetItem * item = m_ui->m_lstModuleCategories->currentItem();
        if (item)
        {
            props.setCategory(item->text().toStdString());
        }
        UIRStatsLaunchConfigDialog(props).exec();
        this->onInitialize(m_ui->m_lstModuleCategories->currentIndex().row());
    }
    catch(std::exception& e)
    {
        UIRStatsErrorMessage("Could not add new module.",std::string(e.what()),false,this).exec();
    }
}

void UIRStatsMain::onLaunchModuleShortcut(QShortcut *button)
{
    launchModule(button->property("path").toString());
}

void UIRStatsMain::onUpdateTableHeader(bool isModuleListSelected)
{
}

void UIRStatsMain::onEditModuleShortcut(QShortcut *button)
{
    editModule(button->property("path").toString(),
               button->property("index").toInt());
}

void UIRStatsMain::onRemoveModuleShortcut(QShortcut *button)
{
    removeModule(button->property("path").toString(),
                 button->property("index").toInt());
}

void UIRStatsMain::onLaunchModule(const RStatsModuleProperties& props, int row)
{    
    launchModule(QString::fromStdString(props.getConfigPath()));
}

void UIRStatsMain::onEditModule(const RStatsModuleProperties& props, int row)
{
    editModule(QString::fromStdString(props.getConfigPath()), row);
}

void UIRStatsMain::onRemoveModule(const RStatsModuleProperties& props, int row)
{
    removeModule(QString::fromStdString(props.getConfigPath()), row);
}

void UIRStatsMain::editModule(const QString &propsPath, int row)
{
    try
    {        
        QListWidgetItem * categoryItem = m_ui->m_lstModuleCategories->currentItem();
        if (categoryItem)
        {
            std::string category = categoryItem->text().toStdString();
            if (m_groupedModules.count(category))
            {
                std::vector<RStatsModuleProperties>&props = m_groupedModules[category];
                if (row < props.size())
                {
                    std::string path = propsPath.toStdString();
                    if (UIRStatsLaunchConfigDialog(props[row]).launch())
                    {
                        //Reload new settings that were saved
                        props[row].loadConfig(path);

                        //New Category Detected
                        if (props[row].getCategory().size() > 0 &&
                            !m_groupedModules.count(props[row].getCategory()))
                        {
                            onInitialize();
                            return;
                        }

                        onRepopulateModules(props);
                        if (m_tblModules && m_tblModules->rowCount() > 0)
                        {
                            m_tblModules->setCurrentCell(0,0);
                            m_tblModules->setFocus();
                            m_tableHasFocus = true;
                        }
                    }
                }
            }
        }
    }
    catch(std::exception& e)
    {
        UIRStatsErrorMessage("Could not edit module",std::string(e.what()),false,this).exec();
    }
}

void UIRStatsMain::removeModule(const QString &propsPath, int row)
{
    try
    {                     
        QListWidgetItem * categoryItem = m_ui->m_lstModuleCategories->currentItem();
        if (categoryItem)
        {
            std::string category = categoryItem->text().toStdString();
            if (m_groupedModules.count(category))
            {
                std::vector<RStatsModuleProperties>&propsList = m_groupedModules[category];
                if (row < propsList.size())
                {
                    utils::RStatsModuleProperties props = propsList[row];
                    int answer = QMessageBox::question(this,"Remove Module...", "Are you sure you want to remove the module \""+QString::fromStdString(props.getName())+"\"",QMessageBox::Yes,QMessageBox::No);
                    if (answer == QMessageBox::Yes)
                    {
                        //Reload new settings that were saved
                        if (row < m_tblModules->rowCount())
                        {
                            //Delete from disk
                            props.removeConfig();

                            //Delete from data
                            propsList.erase(propsList.begin() + row);

                            //Delete from view
                            m_tblModules->removeRow(row);

                            //Check if this is the last module  being deleted in category
                            if (propsList.size() == 0)
                            {
                                m_groupedModules.erase(category);
                                onInitialize();
                            }
                            else
                            {
                                onRepopulateModules(propsList);

                                if (m_tblModules && m_tblModules->rowCount() > 0)
                                {
                                    m_tblModules->setCurrentCell(0,0);
                                    m_tblModules->setFocus();
                                    m_tableHasFocus = true;
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    catch(std::exception& e)
    {
        UIRStatsErrorMessage("Could not remove module",std::string(e.what()),false,this).exec();
    }
}

void UIRStatsMain::launchModule(const QString &propsPath)
{    
    try
    {
        RStatsModuleProperties props;
        props.loadConfig(propsPath.toStdString());
        std::string validatedPath = RStatsUtils::getValidModule(props.getPath());
        props.setPath(validatedPath);
        std::string command,args;
        props.generateApplicationCommand(command,args);
        StringUtils::trimmedInPlace(command);                
        if (FileUtils::fileExists(validatedPath))
        {
            if (!props.isConsoleShown())
            {
                QProcess::startDetached(QString::fromStdString(command + " " + args));
            }
            else
            {
                SystemUtils::executeInTerminal(command,args);
            }
        }

        else
        {
            command = FileUtils::fileExists(FileUtils::buildFilePath(SystemUtils::getCurrentExecutableDirectory(),command));
            if (FileUtils::fileExists(command))
            {
                QProcess::startDetached(QString::fromStdString(command + " " + args));
            }
            else THROW_GENERIC_EXCEPTION("Could not find module at \""+props.getPath()+"\"");
        }
    }
    catch(std::exception& e)
    {
        UIRStatsErrorMessage("Could not launch module",std::string(e.what()),false,this).exec();
    }
}

void UIRStatsMain::onCategoryChanged(int row)
{
    QListWidgetItem * item = m_ui->m_lstModuleCategories->item(row);
    if (item)
    {
        onRepopulateModules(m_groupedModules[item->text().toStdString()]);
    }
}

void UIRStatsMain::onModuleCellActivated(QTableWidgetItem * item)
{
    int row = item->row();
    QString currentCategory;
    if (m_ui->m_lstModuleCategories->currentItem())
    {
        currentCategory = m_ui->m_lstModuleCategories->currentItem()->text();
    }

    if (m_groupedModules.count(currentCategory.toStdString()))
    {
        std::vector<RStatsModuleProperties>& props = m_groupedModules[currentCategory.toStdString()];
        if (row >= 0 && row < props.size())
        {
            //Launch Activations
            if (item->column() == 0)
            {
               onLaunchModule(props[row],row);
            }
            //Edit Activations
            else if (item->column() == 1)
            {
                onEditModule(props[row],row);
            }
            //Remove Activations
            else if (item->column() == 2)
            {
                onRemoveModule(props[row],row);
            }
        }
    }    
}

void UIRStatsMain::keyPressEvent(QKeyEvent *event)
{
    if (m_tblModules == nullptr)
    {
        return;
    }
    if (event->key() == Qt::Key_Delete && m_tableHasFocus)
    {
        QTableWidgetItem * module = m_tblModules->currentItem();
        QListWidgetItem * category = m_ui->m_lstModuleCategories->currentItem();
        if (module && category)
        {
            std::string categoryKey = category->text().toStdString();
            int row = module->row();
            if (m_groupedModules.count(categoryKey) &&
               row < m_groupedModules[categoryKey].size())
            {
                onRemoveModule(m_groupedModules[categoryKey][row],row);
            }
        }
    }
    if (event->key() == Qt::Key_Left || event->key() == Qt::Key_Right)    
    {
        if (m_tableHasFocus)
        {
            m_lastTableRowMap[m_ui->m_lstModuleCategories->currentRow()] = m_tblModules->currentRow();
            m_tableHasFocus = false;
            m_ui->m_lstModuleCategories->setFocus();
            onUpdateTableHeader(m_tableHasFocus);
            m_ui->m_lblModuleCategoryHeader->setStyleSheet("QLabel{padding:4px; border:1px solid gray;background:#BBFFBB;color:black;}");
            m_ui->m_lblModuleHeader->setStyleSheet("QLabel{padding:4px; border:1px solid gray;background:#FFFFFF;color:black;}");
        }
        else
        {
            m_tableHasFocus = true;
            m_tblModules->setFocus();
            onUpdateTableHeader(m_tableHasFocus);
            m_ui->m_lblModuleCategoryHeader->setStyleSheet("QLabel{padding:4px; border:1px solid gray;background:#FFFFFF;color:black;}");
            m_ui->m_lblModuleHeader->setStyleSheet("QLabel{padding:4px; border:1px solid gray;background:#BBFFBB;color:black;}");
            int lastRow = m_lastTableRowMap[m_ui->m_lstModuleCategories->currentRow()];
            if (m_tblModules->rowCount() > 0 &&
                lastRow < m_tblModules->rowCount())
            {
                m_tblModules->setCurrentCell(lastRow,0);
            }
        }
    }  
}
}}}//end namespace

