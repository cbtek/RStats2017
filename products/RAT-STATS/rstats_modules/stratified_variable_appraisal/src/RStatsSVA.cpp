/*
    RStatsSVA.cpp
    

*/
//----------------------------------------
//RStatsSVA.cpp generated by CBTek Solutions on 01-28-2017 at 10:02:20 PM
//----------------------------------------

#include "RStatsSVA.h"
#include "rstats_utils/inc/RStatsObjectList.hpp"
#include "rstats_utils/inc/RStatsUtils.hpp"

#include "utility/inc/Exception.hpp"
#include "utility/inc/StringUtils.hpp"

#include <vector>
#include <cmath>

using namespace oig::ratstats::utils;
using namespace cbtek::common::utility;

namespace oig {
namespace ratstats {
namespace modules {
namespace sva {

CREATE_EXCEPTION_NO_MSG(RStatsSVAException)

namespace constants
{
    const static RStatsFloat ZVAL80 = 1.281551565545;
    const static RStatsFloat ZVAL90 = 1.644853626951;
    const static RStatsFloat ZVAL95 = 1.95996398454;
}

RStatsSVA RStatsSVA::m_instance = RStatsSVA();

RStatsSVAOutputDataList RStatsSVA::execute(RStatsDataFormatType dataFormatType,
                                           const RStatsSVAInputDataList &strataDataList)
{
    RStatsSVAOutputDataList summaryDataList;
    RStatsInteger index = 0;
    m_summaryTotalSum = 0.;
    m_summaryPopulationSize = 0;
    m_summarySampleSize = 0;
    m_summaryNonZero = 0;
    m_summaryPointEstimate = 0.;
    m_summaryStandardErrorMean = 0.;
    m_summaryStandardErrorTotal = 0.;
    m_summaryLowerLimit80 = 0.;
    m_summaryLowerLimit90 = 0.;
    m_summaryLowerLimit95 = 0.;
    m_summaryUpperLimit80 = 0.;
    m_summaryUpperLimit90 = 0.;
    m_summaryUpperLimit95 = 0.;
    m_summaryPrecisionAmount80 = 0.;
    m_summaryPrecisionAmount90 = 0.;
    m_summaryPrecisionAmount95 = 0.;
    m_summaryPrecisionPercent80 = 0.;
    m_summaryPrecisionPercent90 = 0.;
    m_summaryPrecisionPercent95 = 0.;
    m_summaryZValue80 = 0.;
    m_summaryZValue90 = 0.;
    m_summaryZValue95 = 0.;
    m_summaryTValue80 = 0.;
    m_summaryTValue90 = 0.;
    m_summaryTValue95 = 0.;
    m_summaryStandardDeviation = 0.;

    for (const RStatsSVAInputData& inputData : strataDataList)
    {
        onReset();
        m_currentNonZero = RStatsUtils::getNumItemsThatMatchCondition<RStatsFloat>(RStatsConditionalOperatorType::NotEqual,
                                                                                inputData.samples,
                                                                                0.);
        m_examValues.clear();
        m_auditValues.clear();
        m_differenceValues.clear();
        initializeDataTypeFormat(dataFormatType, inputData);
        calculateMean(inputData);
        calculatePointEstimates(inputData);
        calculateCorrectionFactors(inputData);
        calculateDegreesOfFreedom(inputData);
        calculateStandardDeviation(inputData);
        calculateStandardError(inputData);
        calculateSamplingError(inputData);
        calculateIntervals(inputData);

        m_summarySampleSize += inputData.sampleSize;
        m_summaryNonZero += RStatsUtils::getSum(m_outputNonZero);
        m_summaryTotalSum += RStatsUtils::getSum(m_outputSum);
        m_summaryPopulationSize += inputData.universeSize;

        buildOutputData(summaryDataList,
                        inputData,
                        dataFormatType);
        ++index;
    }

    processSummaryTotals(summaryDataList);
    return summaryDataList;
}

RStatsSVAOutputDataList RStatsSVA::execute(
                                           const RStatsWorksheet &inputSheet,
                                           const RStatsWorksheet &sizeSheet,
                                           const RStatsDataFormatTypeIndex & dataSheetIndex,
                                           size_t dataSheetRowStart,
                                           size_t sizeSheetSampleSizeColumn,
                                           size_t sizeSheetUniverseSizeColumn,
                                           size_t sizeSheetRowStart)
{
    std::pair<size_t,size_t> sizeSheetRowColMax = sizeSheet.getLastDataRowAndColumn();
    std::pair<size_t,size_t> inputSheetRowColMax = inputSheet.getLastDataRowAndColumn();

    RStatsSVAInputDataList svaInputList;
    size_t colCount = sizeSheet.getNumColumns();
    size_t dataRow = 0;
    for (size_t r = 0; r < sizeSheet.getNumRows(); ++r)
    {
        RStatsSVAInputData data;

        //Read size info for stratum
        std::string lineCounter = sizeSheet(r, (size_t)0).text;
        std::string universeSize = sizeSheet(r,(size_t)1).text;
        std::string sampleSize = sizeSheet(r,(size_t)2).text;
        data.universeSize = StringUtils::toInt(universeSize);
        data.sampleSize = StringUtils::toInt(sampleSize);

        //For each stratum lets grab the data samples
        for (size_t a1 = dataRow; a1 < data.sampleSize;++a1)
        {
            if (a1 < inputSheet.getNumRows())
            {
                //inputSheet(a1,)
            }
        }
    }

}

void RStatsSVA::populateWorkbookFromOutputList(RStatsSVAOutputDataList &outputList,
                                               RStatsWorkbook &workbookOut)
{
    RStatsInteger counter = 1;
    for(const RStatsSVAOutputData& data : outputList)
    {
        RStatsWorksheet sheet;
        std::string title;
        if (data.isDisplaySummary)
        {
            title = "Summary";
        }
        else
        {
            title = "Stratum "+std::to_string(counter);
        }
        sheet.setDefaultTextAlignment(RStatsTextAlignment::AlignRight);
        sheet.setWorksheetTitle(title);
        sheet.setDefaultFont(cbtek::common::utility::Font("arial",12,true));
        sheet("A1")="Population Size:";
        sheet("A2")="Sample Size:";
        sheet("A3")="Number of Nonzero Items:";

        std::string percent80 = StringUtils::toString(data.precisionPercent80,2)+"%";
        std::string percent90 = StringUtils::toString(data.precisionPercent90,2)+"%";
        std::string percent95 = StringUtils::toString(data.precisionPercent95,2)+"%";

        if (data.isDisplaySummary)
        {
            sheet("A4") = "Standard Error (Mean):";
            sheet("A5") = "Standard Error (Total):";
            sheet("A6") = "Point Estimate:";
            sheet("D3") = "Lower Limit:";
            sheet("D4") = "Upper Limit:";
            sheet("D5") = "Precision Amount:";
            sheet("D6") = "Precision Percent:";
            sheet("D7") = "Z-Value Used:";
            sheet.setDefaultTextAlignment(RStatsTextAlignment::AlignMiddle);
            sheet("F1") = "Confidence Levels";
            sheet("E2") = "80%";
            sheet("F2") = "90%";
            sheet("G2") = "95%";
            sheet("E2").bgColor.set(255,127,127);
            sheet("F2").bgColor.set(255,255,127);
            sheet("G2").bgColor.set(127,255,127);
            sheet.resetDefaults();
            sheet.setDefaultFloatingPointDecimals(2);
            sheet("B1") = data.populationSize;
            sheet("B2") = data.sampleSize;
            sheet("B3") = data.nonZeroCount;
            sheet("B4") = data.standardErrorMean;
            sheet("B5") = data.standardErrorTotal;

            sheet.setDefaultFloatingPointDecimals(0);
            sheet("B6") = data.pointEstimate;
            sheet("E3") = data.lower80;
            sheet("F3") = data.lower90;
            sheet("G3") = data.lower95;

            sheet("E4") = data.upper80;
            sheet("F4") = data.upper90;
            sheet("G4") = data.upper95;

            sheet("E5") = data.precisionAmount80;
            sheet("F5") = data.precisionAmount90;
            sheet("G5") = data.precisionAmount95;

            sheet("E6") = percent80;
            sheet("F6") = percent90;
            sheet("G6") = percent95;

            sheet.setDefaultFloatingPointDecimals(12);
            sheet("E7") = data.tValue80;
            sheet("F7") = data.tValue90;
            sheet("G7") = data.tValue95;
        }
        else
        {
            sheet("A4")="Mean:";
            sheet("A5")="Skew:";
            sheet("A6")="Point Estimate:";
            sheet("A7")="Standard Error (Mean):";
            sheet("A8")="Standard Error (Total):";
            sheet("A9")="Point Estimate:";
            sheet("D4") = "Lower Limit:";
            sheet("D5") = "Upper Limit:";
            sheet("D6") = "Precision Amount:";
            sheet("D7") = "Precision Percent:";
            sheet("D8") = "t-Value Used:";
            sheet.setDefaultTextAlignment(RStatsTextAlignment::AlignMiddle);
            sheet("F2") = "Confidence Levels";
            sheet("E3") = "80%";
            sheet("F3") = "90%";
            sheet("G3") = "95%";
            sheet("E3").bgColor.set(255,127,127);
            sheet("F3").bgColor.set(255,255,127);
            sheet("G3").bgColor.set(127,255,127);
            sheet.resetDefaults();


            sheet.setDefaultFloatingPointDecimals(2);
            sheet("B1") = data.populationSize;
            sheet("B2") = data.sampleSize;
            sheet("B3") = data.nonZeroCount;
            sheet("B4") = data.mean;
            sheet("B5") = data.standardDeviation;
            sheet("B6") = data.skewness;
            sheet("B7") = data.standardErrorMean;
            sheet("B8") = data.standardErrorTotal;

            sheet.setDefaultFloatingPointDecimals(0);
            sheet("B9") = data.pointEstimate;
            sheet("E4") = data.lower80;
            sheet("F4") = data.lower90;
            sheet("G4") = data.lower95;

            sheet("E5") = data.upper80;
            sheet("F5") = data.upper90;
            sheet("G5") = data.upper95;

            sheet("E6") = data.precisionAmount80;
            sheet("F6") = data.precisionAmount90;
            sheet("G6") = data.precisionAmount95;

            sheet("E7") = percent80;
            sheet("F7") = percent90;
            sheet("G7") = percent95;

            sheet.setDefaultFloatingPointDecimals(12);
            sheet("E8") = data.tValue80;
            sheet("F8") = data.tValue90;
            sheet("G8") = data.tValue95;
        }
        workbookOut.addWorksheet(sheet);
        ++counter;
    }
}

void RStatsSVA::buildOutputData(RStatsSVAOutputDataList& outputDataList,
                                const RStatsSVAInputData& inputData,
                                RStatsDataFormatType type)
{
    if (type == RStatsDataFormatType::Examine ||
        type == RStatsDataFormatType::ExamineAndAudit||
        type == RStatsDataFormatType::ExamineAndDifference)
    {
        RStatsSVAOutputData examine;
        copyOutputData(examine,inputData,type,0);
        outputDataList.push_back(examine);
    }

    if (type == RStatsDataFormatType::Audit ||
        type == RStatsDataFormatType::AuditAndDifference ||
        type == RStatsDataFormatType::ExamineAndAudit)
    {
        RStatsSVAOutputData audit;
        copyOutputData(audit,inputData,type,1);
        outputDataList.push_back(audit);
    }

    if (type == RStatsDataFormatType::Difference ||
        type == RStatsDataFormatType::AuditAndDifference ||
        type == RStatsDataFormatType::ExamineAndDifference)
    {
        RStatsSVAOutputData difference;
        copyOutputData(difference,inputData,type,2);
        outputDataList.push_back(difference);
    }

}


void RStatsSVA::copyOutputData(RStatsSVAOutputData& outputData,
                               const RStatsSVAInputData& inputData,
                               RStatsDataFormatType type,
                               RStatsInteger dataFormatIndex)
{
    outputData.type = type;
    outputData.sampleSize = inputData.sampleSize;
    outputData.populationSize = inputData.universeSize;
    outputData.nonZeroCount = m_outputNonZero(dataFormatIndex);
    outputData.mean = m_outputMean(dataFormatIndex);
    outputData.standardDeviation = m_outputStdDev(dataFormatIndex);
    outputData.skewness = m_outputSkewAmount(dataFormatIndex);
    outputData.standardErrorMean = m_outputStdErr(dataFormatIndex);
    outputData.standardErrorTotal = m_outputStdErr(dataFormatIndex) * inputData.universeSize;
    outputData.pointEstimate = m_outputPNTest(dataFormatIndex);
    outputData.lower80 = m_outputLowerLimit80(dataFormatIndex);
    outputData.lower90 = m_outputLowerLimit90(dataFormatIndex);
    outputData.lower95 = m_outputLowerLimit95(dataFormatIndex);
    outputData.upper80 = m_outputUpperLimit80(dataFormatIndex);
    outputData.upper90 = m_outputUpperLimit90(dataFormatIndex);
    outputData.upper95 = m_outputUpperLimit95(dataFormatIndex);

    outputData.precisionAmount80 = m_outputPrecision80(dataFormatIndex) * inputData.universeSize;
    outputData.precisionAmount90 = m_outputPrecision90(dataFormatIndex) * inputData.universeSize;
    outputData.precisionAmount95 = m_outputPrecision95(dataFormatIndex) * inputData.universeSize;

    if (outputData.mean > 0)
    {
        outputData.precisionPercent80 = m_outputPrecision80(dataFormatIndex) / outputData.mean;
        outputData.precisionPercent90 = m_outputPrecision90(dataFormatIndex) / outputData.mean;
        outputData.precisionPercent95 = m_outputPrecision95(dataFormatIndex) / outputData.mean;
    }

    outputData.tValue80 = m_outputTValue80;
    outputData.tValue90 = m_outputTValue90;
    outputData.tValue95 = m_outputTValue95;

}


RStatsSVA & RStatsSVA::inst()
{
    return m_instance;
}

RStatsSVA::RStatsSVA()
{
    m_totalSampleSize = 0;
    onReset();
}

RStatsSVA::~RStatsSVA()
{

}

void RStatsSVA::onReset()
{
    m_outputSampleError80 = 0.;
    m_outputSampleError90 = 0.;
    m_outputSampleError95 = 0.;
    m_outputTValue80 = 0.;
    m_outputTValue90 = 0.;
    m_outputTValue95 = 0.;
    m_formulaVarA = 0.;
    m_formulaVarB = 0.;
    m_formulaVarT = 0.;
    m_formulaVarPI = 0.;
    m_formulaVarX = 0.;
    m_formulaVarC0 = 0.;
    m_frontValue = 0.;
    m_eps = 0.;
    m_outputDOF = 0.;
    m_outputSEFIN = 0.;
    m_formulaVarTLast = 0.;
    m_lowValue = 0.;
    m_highValue = 0.;
    m_newProbability = 0.;
    m_lowProbability = 0.;
    m_highProbability = 0.;
    m_difference = 0.;
    m_cumaltiveProbability = 0.;
    m_currentProbability = 0.;
    m_temporary80 = 0.;
    m_temporary90 = 0.;
    m_temporary95 = 0.;
    m_lastLogValue = 0.;
    m_logValue1 = 0.;
    m_logValue2 = 0.;
    m_logValue3 = 0.;
    m_logValue4 = 0.;
    m_totalAmount = 0.;
    m_examineSum = 0.;
    m_auditSum = 0.;
    m_differenceSum = 0.;
    m_dataFormatTypeAvailableFlag.initialize(3);
    m_outputNonZero.initialize(3);
    m_outputSkewAmount.initialize(3);
    m_outputSkewVAmount.initialize(3);
    m_outputKurtosisAmount.initialize(3);
    m_outputKurtosisVAmount.initialize(3);
    m_valuesC.initialize(1000);
    m_outputSum.initialize(3);
    m_outputSumSqrt.initialize(3);
    m_outputSumCbrt.initialize(3);
    m_outputSumQdrt.initialize(3);
    m_examValues.initialize(3);
    m_auditValues.initialize(3);
    m_differenceValues.initialize(3);
    m_outputMean.initialize(3);
    m_outputPrecision80.initialize(3);
    m_outputPrecision90.initialize(3);
    m_outputPrecision95.initialize(3);
    m_outputVPrecision80.initialize(3);
    m_outputVPrecision90.initialize(3);
    m_outputVPrecision95.initialize(3);
    m_outputPNTest.initialize(3);
    m_outputPNTestTemp.initialize(3);
    m_outputVMean.initialize(3);
    m_outputVProjectNumber.initialize(3);
    m_outputStdDev.initialize(3);
    m_outputStdErr.initialize(3);
    m_outputVStdDev.initialize(3);
    m_outputTermSE.initialize(3);
    m_outputStdDevTemp.initialize(3);
    m_outputStdErrTemp.initialize(3);
    m_outputUpperLimit80.initialize(3);
    m_outputUpperLimit90.initialize(3);
    m_outputUpperLimit95.initialize(3);
    m_outputLowerLimit80.initialize(3);
    m_outputLowerLimit90.initialize(3);
    m_outputLowerLimit95.initialize(3);
    m_outputVUpperLimit80.initialize(3);
    m_outputVUpperLimit90.initialize(3);
    m_outputVUpperLimit95.initialize(3);
    m_outputVLowerLimit80.initialize(3);
    m_outputVLowerLimit90.initialize(3);
    m_outputVLowerLimit95.initialize(3);
    m_outputUpperLimitTemp80.initialize(3);
    m_outputUpperLimitTemp90.initialize(3);
    m_outputUpperLimitTemp95.initialize(3);
    m_outputLowerLimitTemp80.initialize(3);
    m_outputLowerLimitTemp90.initialize(3);
    m_outputLowerLimitTemp95.initialize(3);
    m_outputPrecisionTemp80.initialize(3);
    m_outputPrecisionTemp90.initialize(3);
    m_outputPrecisionTemp95.initialize(3);
    m_outputVStdErr.initialize(3);
    m_outputNonZeroTemp.initialize(3);

    m_currentIteration = 0;
    m_currentNonZero = 0;
    m_examineZeroCount = 0;
    m_auditZeroCount = 0;
    m_differenceZeroCount = 0;
    m_outputNonZeroSize = 0;
    m_numTerms = 0;
    m_maxIterations = 0;
    m_numStrata = 0;
    m_conditionCount = 0;
    m_conditionUsage = 0;
}

void RStatsSVA::onUpdateSums(const RStatsFloatList &auditValues,
                             const RStatsFloatList &examValues,
                             const RStatsFloatList &differenceValues
                            )
{

    m_outputSum(0) += RStatsUtils::getSum(examValues);
    m_outputSumSqrt(0) += RStatsUtils::getSumRaisedTo<RStatsFloat>(examValues,2);
    m_outputSumCbrt(0) += RStatsUtils::getSumRaisedTo<RStatsFloat>(examValues,3);
    m_outputSumQdrt(0) += RStatsUtils::getSumRaisedTo<RStatsFloat>(examValues,4);
    m_outputNonZero(0) += RStatsUtils::getNumItemsThatMatchCondition(RStatsConditionalOperatorType::NotEqual,
                                                                     examValues,
                                                                     0.);

    m_outputSum(1) += RStatsUtils::getSum(auditValues);
    m_outputSumSqrt(1) += RStatsUtils::getSumRaisedTo<RStatsFloat>(auditValues,2);
    m_outputSumCbrt(1) += RStatsUtils::getSumRaisedTo<RStatsFloat>(auditValues,3);
    m_outputSumQdrt(1) += RStatsUtils::getSumRaisedTo<RStatsFloat>(auditValues,4);
    m_outputNonZero(1) += RStatsUtils::getNumItemsThatMatchCondition(RStatsConditionalOperatorType::NotEqual,
                                                                     auditValues,
                                                                     0.);

    m_outputSum(2) += RStatsUtils::getSum(differenceValues);
    m_outputSumSqrt(2) += RStatsUtils::getSumRaisedTo<RStatsFloat>(differenceValues,2);
    m_outputSumCbrt(2) += RStatsUtils::getSumRaisedTo<RStatsFloat>(differenceValues,3);
    m_outputSumQdrt(2) += RStatsUtils::getSumRaisedTo<RStatsFloat>(differenceValues,4);
    m_outputNonZero(2) += RStatsUtils::getNumItemsThatMatchCondition(RStatsConditionalOperatorType::NotEqual,
                                                                     differenceValues,
                                                                     0.);

}


void RStatsSVA::initializeDataTypeFormat(RStatsDataFormatType dataTypeFormat,
                                         const RStatsSVAInputData &inputData)
{
    if (dataTypeFormat == RStatsDataFormatType::Examine)
    {
        m_examineZeroCount = RStatsUtils::getNumItemsThatMatchCondition(RStatsConditionalOperatorType::NotEqual,
                                                                        inputData.samples,
                                                                        0.0,
                                                                        0);
        m_dataFormatTypeAvailableFlag(0) = true;
        m_examineSum = RStatsUtils::getSum(inputData.samples);
        m_outputSum(0) += m_examineSum;
        m_outputSumSqrt(0) += RStatsUtils::getSumRaisedTo<RStatsFloat>(inputData.samples,2);
        m_outputSumCbrt(0) += RStatsUtils::getSumRaisedTo<RStatsFloat>(inputData.samples,3);
        m_outputSumQdrt(0) += RStatsUtils::getSumRaisedTo<RStatsFloat>(inputData.samples,4);
        m_outputNonZero(0) += m_examineZeroCount;
    }
    else if (dataTypeFormat == RStatsDataFormatType::Audit)
    {
        m_auditZeroCount = RStatsUtils::getNumItemsThatMatchCondition(RStatsConditionalOperatorType::NotEqual,
                                                                      inputData.samples,
                                                                      0.0,
                                                                      0);
        m_dataFormatTypeAvailableFlag(1) = true;
        m_auditSum = RStatsUtils::getSum(inputData.samples);
        m_outputSum(1) += m_auditSum;
        m_outputSumSqrt(1) += RStatsUtils::getSumRaisedTo<RStatsFloat>(inputData.samples,2);
        m_outputSumCbrt(1) += RStatsUtils::getSumRaisedTo<RStatsFloat>(inputData.samples,3);
        m_outputSumQdrt(1) += RStatsUtils::getSumRaisedTo<RStatsFloat>(inputData.samples,4);
        m_outputNonZero(1) += m_auditZeroCount;

    }
    else if (dataTypeFormat == RStatsDataFormatType::Difference)
    {
        m_differenceZeroCount = RStatsUtils::getNumItemsThatMatchCondition(RStatsConditionalOperatorType::NotEqual,
                                                                           inputData.samples,
                                                                           0.0,
                                                                           0);
        m_dataFormatTypeAvailableFlag(2) = true;
        m_differenceSum = RStatsUtils::getSum(inputData.samples);
        m_outputSum(2) += m_differenceSum;
        m_outputSumSqrt(2) += RStatsUtils::getSumRaisedTo<RStatsFloat>(inputData.samples,2);
        m_outputSumCbrt(2) += RStatsUtils::getSumRaisedTo<RStatsFloat>(inputData.samples,3);
        m_outputSumQdrt(2) += RStatsUtils::getSumRaisedTo<RStatsFloat>(inputData.samples,4);
        m_outputNonZero(2) += m_differenceZeroCount;

    }
    else if (dataTypeFormat == RStatsDataFormatType::ExamineAndAudit)
    {
        if (inputData.samples.getNumDimensions() > 1)
        {
            m_examValues.appendDimension(inputData.samples,0);
            m_auditValues.appendDimension(inputData.samples,1);
            m_differenceValues = RStatsUtils::getNumbersSubtracted(m_examValues,m_auditValues);
            m_examineSum = RStatsUtils::getSum(m_examValues);
            m_differenceSum = RStatsUtils::getSum(m_differenceValues);
            m_auditSum = RStatsUtils::getSum(m_auditValues);
            m_dataFormatTypeAvailableFlag(0) = true;
            m_dataFormatTypeAvailableFlag(1) = true;
            m_dataFormatTypeAvailableFlag(2) = true;

            onUpdateSums(m_auditValues,
                     m_examValues,
                     m_differenceValues);
        }
    }

    else if (dataTypeFormat == RStatsDataFormatType::ExamineAndDifference)
    {
        if (inputData.samples.getNumDimensions() > 1)
        {
            m_examValues.appendDimension(inputData.samples,0);
            m_differenceValues.appendDimension(inputData.samples,1);
            m_auditValues = RStatsUtils::getNumbersSubtracted(m_examValues,m_differenceValues);
            m_examineSum = RStatsUtils::getSum(m_examValues);
            m_differenceSum = RStatsUtils::getSum(m_differenceValues);
            m_auditSum = RStatsUtils::getSum(m_auditValues);

            m_dataFormatTypeAvailableFlag(0) = true;
            m_dataFormatTypeAvailableFlag(1) = true;
            m_dataFormatTypeAvailableFlag(2) = true;

            onUpdateSums(m_auditValues,
                     m_examValues,
                     m_differenceValues);

        }
    }

    else if (dataTypeFormat == RStatsDataFormatType::AuditAndDifference)
    {
        if (inputData.samples.getNumDimensions() > 1)
        {
            m_auditValues.appendDimension(inputData.samples,0);
            m_differenceValues.appendDimension(inputData.samples,1);
            m_examValues = RStatsUtils::getNumbersAdded(m_auditValues,m_differenceValues);
            m_examineSum = RStatsUtils::getSum(m_examValues);
            m_differenceSum = RStatsUtils::getSum(m_differenceValues);
            m_auditSum = RStatsUtils::getSum(m_auditValues);

            m_dataFormatTypeAvailableFlag(0) = true;
            m_dataFormatTypeAvailableFlag(1) = true;
            m_dataFormatTypeAvailableFlag(2) = true;

            onUpdateSums(m_auditValues,
                     m_examValues,
                     m_differenceValues);
        }
    }
}
//'---------CALCULATE MEAN--------
void RStatsSVA::calculateMean(const RStatsSVAInputData& inputData)
{
    for (RStatsInteger a1 = 0; a1 < 3; ++a1)
    {
        if (inputData.sampleSize > 0 &&
            m_currentNonZero > 0 &&
            m_dataFormatTypeAvailableFlag(a1))
        {
            m_outputMean(a1) = m_outputSum(a1) / (RStatsFloat)inputData.sampleSize;
            m_outputVMean(a1) = m_outputMean(a1);
        }
    }
}

//'----------CALCULATE STANDARD DEVIATION----------
void RStatsSVA::calculateStandardDeviation(const RStatsSVAInputData &inputData)
{
    for (RStatsInteger a1 = 0; a1 < 3; ++a1)
    {
        if (!RStatsUtils::isEqual<RStatsFloat>(m_outputSum(a1), 0.0) &&
            inputData.sampleSize > 1 &&
            m_dataFormatTypeAvailableFlag(a1))
        {
            RStatsFloat totalAmount = m_outputSum(a1);
            RStatsFloat sampleSize = inputData.sampleSize;
            RStatsFloat sqRt = m_outputSumSqrt(a1);
            RStatsFloat universeSize = inputData.universeSize;
            double temp1 = std::pow(totalAmount,2) / sampleSize;
            if (temp1 < sqRt)
            {
                m_outputStdDev(a1) = (std::sqrt((sqRt - temp1) / m_outputDOF));
            }
            else
            {
                m_outputStdDev(a1) = 0.;
            }
            m_outputStdDevTemp(a1) += (m_outputStdDevTemp(a1) + std::pow(m_outputStdDev(a1),2) * std::pow(universeSize,2));
            m_summaryStandardDeviation += m_outputStdDevTemp(a1);
        }
        m_outputVStdDev(a1) = m_outputStdDev(a1);
    }
}

//'----------CALCULATE STANDARD ERROR----------
void RStatsSVA::calculateStandardError(const RStatsSVAInputData& inputData)
{
    for (RStatsInteger a1 = 0; a1 < 3; ++a1)
    {
        if (!RStatsUtils::isEqual<RStatsFloat>(m_outputStdDev(a1), 0.0) &&
            inputData.sampleSize > 1 &&
            m_dataFormatTypeAvailableFlag(a1))
        {
            RStatsFloat stdDev = m_outputStdDev(a1);
            RStatsFloat sqrSampSize = std::sqrt(inputData.sampleSize);
            m_outputStdErr(a1) = (stdDev / sqrSampSize) * m_outputSEFIN;
            RStatsFloat tempValue = inputData.universeSize;
            tempValue *= (inputData.universeSize - inputData.sampleSize);
            tempValue *= (std::pow(m_outputStdDev(a1),2));
            tempValue /= (RStatsFloat) inputData.sampleSize;
            m_outputTermSE(a1) = tempValue;
            m_outputStdErrTemp(a1) += m_outputTermSE(a1);
            m_summaryStandardErrorMean += m_outputStdErrTemp(a1);
        }
    }
}

//'---------CALCULATE CORRECTION FACTORS-------
void RStatsSVA::calculateCorrectionFactors(const RStatsSVAInputData& inputData)
{
    if (inputData.universeSize > 1)
    {
         m_outputSEFIN = std::sqrt((inputData.universeSize - inputData.sampleSize) / (inputData.universeSize));
    }
}

//'---------CALCULATE DEGREES OF FREEDOM-------
void RStatsSVA::calculateDegreesOfFreedom(const RStatsSVAInputData& inputData)
{
    m_outputDOF = inputData.sampleSize - 1;
}

//'----------CALCULATE POINT ESTIMATES------
void RStatsSVA::calculatePointEstimates(const RStatsSVAInputData& inputData)
{
    for (RStatsInteger a1 = 0; a1 < 3; ++a1)
    {
        m_outputPNTest(a1) = m_outputMean(a1) * (RStatsFloat)inputData.universeSize;
        m_outputPNTestTemp(a1) = m_outputPNTestTemp(a1) + m_outputPNTest(a1);
        m_summaryPointEstimate += m_outputPNTest(a1);
        m_outputVProjectNumber(a1) = m_outputPNTest(a1);
    }
}

//'----------CALCULATE LOWER AND UPPER LIMITS-----------
void RStatsSVA::calculateUpperAndLowerLimits(const RStatsSVAInputData& inputData)
{
    for (RStatsInteger a1 = 0; a1 < 3; ++a1)
    {
        double temp0 = m_outputPrecision80(a1) * inputData.universeSize;
        double temp1 = m_outputPrecision90(a1) * inputData.universeSize;
        double temp2 = m_outputPrecision95(a1) * inputData.universeSize;

        m_outputLowerLimit80(a1) = m_outputPNTest(a1) - temp0;
        m_outputLowerLimit90(a1) = m_outputPNTest(a1) - temp1;
        m_outputLowerLimit95(a1) = m_outputPNTest(a1) - temp2;
        m_outputUpperLimit80(a1) = m_outputPNTest(a1) + temp0;
        m_outputUpperLimit90(a1) = m_outputPNTest(a1) + temp1;
        m_outputUpperLimit95(a1) = m_outputPNTest(a1) + temp2;
        m_outputVUpperLimit80(a1) = m_outputUpperLimit80(a1);
        m_outputVLowerLimit80(a1) = m_outputLowerLimit80(a1);
        m_outputVLowerLimit90(a1) = m_outputLowerLimit90(a1);
        m_outputVUpperLimit90(a1) = m_outputUpperLimit90(a1);
        m_outputVLowerLimit95(a1) = m_outputLowerLimit95(a1);
        m_outputVUpperLimit95(a1) = m_outputUpperLimit95(a1);
    }
}

//'----------CALCULATE SKEWNESS-----------
void RStatsSVA::calculateSkewness(const RStatsSVAInputData& inputData)
{
    for (RStatsInteger a1 = 0; a1 < 3; ++a1)
    {
        if (inputData.sampleSize > 0 &&
            m_currentNonZero > 0 &&
            m_dataFormatTypeAvailableFlag(a1))
        {
            RStatsFloat temp1 = m_outputSumCbrt(a1) / inputData.sampleSize;
            temp1 -= (3 * (m_outputSumSqrt(a1) / inputData.sampleSize) * m_outputMean(a1));
            temp1 += (2 * std::pow(m_outputMean(a1),3));
            RStatsFloat temp2;
            if (m_outputSumSqrt(a1) / inputData.sampleSize > std::pow(m_outputMean(a1),2))
            {
                temp2 = std::sqrt(m_outputSumSqrt(a1) / inputData.sampleSize - (std::pow(m_outputMean(a1),2)));
            }
            else
            {
                temp2 = 0;
            }
            if (temp2 > 1 || RStatsUtils::isEqual<RStatsFloat>(temp2, 1.))
            {
                m_outputSkewAmount(a1) = temp1 / std::pow(temp2,3);
            }
        }
        m_outputSkewVAmount(a1) = m_outputSkewAmount(a1);
    }
}

//'----------CALCULATE KURTOSIS-------------
void RStatsSVA::calculateKurtosis(const RStatsSVAInputData& inputData)
{
    for (RStatsInteger a1 = 0; a1 < 3; ++a1)
    {
        if (inputData.sampleSize > 0 &&
            m_currentNonZero > 0 &&
            m_dataFormatTypeAvailableFlag(a1))
        {
            RStatsFloat cubeRt = m_outputSumCbrt(a1);
            RStatsFloat quadRt = m_outputSumQdrt(a1);
            RStatsFloat sqRt = m_outputSumSqrt(a1);
            RStatsFloat sampSize = (RStatsFloat)inputData.sampleSize;
            RStatsFloat mean = m_outputMean(a1);

            RStatsFloat temp1 = quadRt / sampSize;
            temp1 -= (4 * (cubeRt / sampSize)) * mean;
            temp1 += (6 * (sqRt / sampSize) * std::pow(mean,2));
            temp1 -= (3 * std::pow(mean,4));
            RStatsFloat temp2 = 0.;
            if (sqRt / sampSize > std::pow(mean,2))
            {
                temp2 = std::sqrt(sqRt / sampSize - std::pow(mean,2));
            }
            else
            {
                temp2 = 0;
            }
            if (temp2 > 1 || RStatsUtils::isEqual<RStatsFloat>(temp2,1.))
            {
                m_outputKurtosisAmount(a1) = temp1 / std::pow(temp2,4);
            }
        }
        m_outputKurtosisVAmount(a1) = m_outputKurtosisAmount(a1);
    }
}

//'---------CALCULATE SAMPLING ERROR---------
void RStatsSVA::calculateSamplingError(const RStatsSVAInputData& inputData)
{
    m_temporary80 = 0.;
    m_temporary90 = 0.;
    m_temporary95 = 0.;
    if (m_outputDOF > 3)
    {
        processSamplingError(inputData);
    }
    else if (m_outputDOF == 1)
    {
        m_outputSampleError80 = 3.077683537175;
        m_outputSampleError90 = 6.313751514675;
        m_outputSampleError95 = 12.706204736175;
    }
    else if (m_outputDOF == 2)
    {
        m_outputSampleError80 = 1.885618083164;
        m_outputSampleError90 = 2.919985580354;
        m_outputSampleError95 = 4.30265272975;
    }
    else if (m_outputDOF == 3)
    {
        m_outputSampleError80 = 1.637744353696;
        m_outputSampleError90 = 2.353363434802;
        m_outputSampleError95 = 3.182446305284;
    }
    processSamplingError(inputData);
}

void RStatsSVA::processSamplingError(const RStatsSVAInputData& inputData)
{
    m_numTerms = 100;
    m_maxIterations = 1000;
    m_eps = 0.00000000000001;
    m_formulaVarA = 0.5;
    m_formulaVarB = m_outputDOF / 2;
    m_formulaVarPI = 4 * std::atan(1);
    m_conditionCount = 0;
    processConditionLoop(inputData);
}

void RStatsSVA::processConditionLoop(const RStatsSVAInputData& inputData)
{
    m_conditionCount++;
    m_lowValue = 0;
    m_highValue = 4;

    if (m_conditionCount == 1)
    {
        m_conditionUsage = 80;
    }
    else if (m_conditionCount == 2)
    {
        m_conditionUsage = 90;
    }
    else if (m_conditionCount == 3)
    {
        m_conditionUsage = 95;
    }
    m_cumaltiveProbability = (RStatsFloat)m_conditionUsage / 200 + .5;

    m_formulaVarT = m_lowValue;
    processFindCumProb(inputData);
    m_lowProbability = m_currentProbability;

    m_formulaVarT = m_highValue;
    processFindCumProb(inputData);
    m_highProbability = m_currentProbability;

    m_currentIteration = 0;
    processStartLoop(inputData);
}

void RStatsSVA::processStartLoop(const RStatsSVAInputData& inputData)
{
    m_currentIteration++;
    m_formulaVarTLast = m_formulaVarT;
    m_formulaVarT = (m_lowValue + m_highValue) / 2;
    processFindCumProb(inputData);
    m_newProbability = m_currentIteration;
    if (m_currentProbability < m_cumaltiveProbability)
    {
        m_lowValue = m_formulaVarT;
    }
    else
    {
        m_highValue = m_formulaVarT;
    }

    m_difference = fabsl(m_formulaVarT - m_formulaVarTLast) - m_eps;
    if (m_difference < 0 || RStatsUtils::isEqual<RStatsFloat>(m_formulaVarT,0.))
    {
        if (m_conditionCount == 1)
        {
            m_temporary80 = m_formulaVarT;
        }
        else if (m_conditionCount == 2)
        {
            m_temporary90 = m_formulaVarT;
        }
        else if (m_conditionCount == 3)
        {
            m_temporary95 = m_formulaVarT;
        }
    }
    else
    {
        if (m_currentIteration < m_maxIterations)
        {
            processStartLoop(inputData);
        }
        else
        {
            throw RStatsSVAException(EXCEPTION_TAG_LINE+"Program was unable to determine a t-value");
        }
    }
    if (m_conditionCount < 3)
    {
        processConditionLoop(inputData);
    }
    else
    {
        calculateIntervals(inputData);
    }
}

void RStatsSVA::processFindCumProb(const RStatsSVAInputData& inputData)
{
    m_formulaVarX = std::pow(m_formulaVarT,2) / (std::pow(m_formulaVarT,2) + m_outputDOF);
    RStatsInteger numTermsTemp = 0;
    if (m_outputDOF == 2)
    {
        m_formulaVarC0 = 1;
        processFindTerms(inputData);
    }
    else if (m_outputDOF == 3)
    {
        m_formulaVarC0 = 4 / m_formulaVarPI;
        processFindTerms(inputData);
    }
    if ((m_outputDOF - 2 * (int)(m_outputDOF / 2) == 0))
    {
        m_formulaVarC0 = 1;
        numTermsTemp = m_outputDOF / 2 - 1;
        for (RStatsInteger a1 = 0; a1 < numTermsTemp; ++a1)
        {
            RStatsFloat temp = 2 * (a1+1) + 1;
            m_formulaVarC0 = (m_formulaVarC0 * temp) / (temp - 1);
        }
        processFindTerms(inputData);
    }
    else
    {
        m_formulaVarC0 = 4 / m_formulaVarPI;
        numTermsTemp = ((m_outputDOF - 1) / 2) - 1;
        for (RStatsInteger a1 = 0; a1 < numTermsTemp; ++a1)
        {
            RStatsFloat temp = 2 * (a1+1) + 2;
            m_formulaVarC0 = (m_formulaVarC0 * temp) / (temp - 1);
        }
    }
    processFindTerms(inputData);
}

void RStatsSVA::processFindTerms(const RStatsSVAInputData& inputData)
{
    m_frontValue = std::pow((1 - m_formulaVarX), m_formulaVarB) * std::pow(m_formulaVarX,m_formulaVarA);
    RStatsFloat tempValue = m_formulaVarC0;
    m_valuesC(0) = m_formulaVarC0;
    RStatsFloat logOld = std::log(m_valuesC(0));
    if (RStatsUtils::isEqual<RStatsFloat>(m_formulaVarX,0))
    {
        tempValue = 0;
        processFindProbVal(tempValue);
        return;
    }
    for (RStatsInteger a1 = 0; a1 < m_numTerms;++a1)
    {
        m_logValue1 = std::log((a1 + m_formulaVarA + m_formulaVarB) / (a1+1+m_formulaVarA));
        m_logValue2 = logOld;
        m_logValue3 = std::log(m_formulaVarX);
        m_logValue4 = m_logValue1 + m_logValue2 + (a1 + 1) * std::log(m_formulaVarX);
        logOld = m_logValue1 + m_logValue2;
        tempValue = tempValue + std::exp(m_logValue4);
    }
    processFindProbVal(tempValue);
}

void RStatsSVA::processFindProbVal(RStatsFloat tempValue)
{
    m_currentProbability = .5 * (m_frontValue * tempValue + 1);
}

void RStatsSVA::processSummaryTotals(RStatsSVAOutputDataList& outputData)
{
    int x = 0;
    RStatsSVAOutputData summary;
    summary.pointEstimate = m_summaryPointEstimate;
    summary.nonZeroCount = m_summaryNonZero;
    summary.sampleSize = m_summarySampleSize;
    summary.populationSize = m_summaryPopulationSize;
    summary.lower80 = m_summaryLowerLimit80;
    summary.lower90 = m_summaryLowerLimit90;
    summary.lower95 = m_summaryLowerLimit95;

    summary.upper80 = m_summaryUpperLimit80;
    summary.upper90 = m_summaryUpperLimit90;
    summary.upper95 = m_summaryUpperLimit95;

    summary.precisionAmount80 = m_summaryPrecisionAmount80;
    summary.precisionAmount90 = m_summaryPrecisionAmount90;
    summary.precisionAmount95 = m_summaryPrecisionAmount95;

    summary.precisionPercent80 = m_summaryPrecisionPercent80;
    summary.precisionPercent90 = m_summaryPrecisionPercent90;
    summary.precisionPercent95 = m_summaryPrecisionPercent95;

    summary.standardErrorMean = m_summaryStandardErrorMean;
    summary.standardErrorTotal = m_summaryStandardErrorTotal;
    summary.standardDeviation = m_summaryStandardDeviation;
    summary.isDisplaySummary = true;
    outputData.insert(outputData.begin()+0, summary);
}

void RStatsSVA::calculateIntervals(const RStatsSVAInputData & inputData)
{
    m_outputTValue80 = m_temporary80;
    m_outputTValue90 = m_temporary90;
    m_outputTValue95 = m_temporary95;

    for (RStatsInteger a1 = 0; a1 < 3; ++a1)
    {
        if (m_outputNonZero(a1) > 0)
        {
            m_outputPrecision80(a1) = m_temporary80 * m_outputStdErr(a1);
            m_outputPrecision90(a1) = m_temporary90 * m_outputStdErr(a1);
            m_outputPrecision95(a1) = m_temporary95 * m_outputStdErr(a1);
        }

        m_outputVPrecision80(a1) = m_outputPrecision80(a1) * (RStatsFloat)inputData.universeSize;
        m_outputVPrecision90(a1) = m_outputPrecision90(a1) * (RStatsFloat)inputData.universeSize;
        m_outputVPrecision95(a1) = m_outputPrecision95(a1) * (RStatsFloat)inputData.universeSize;
    }

    calculateUpperAndLowerLimits(inputData);
    calculateSkewness(inputData);
    calculateKurtosis(inputData);
    calculateOverallPrecision(inputData);
}

void RStatsSVA::calculateOverallPrecision(const RStatsSVAInputData &inputData)
{
    for (RStatsInteger a1 = 0; a1 < 3; ++a1)
    {
        if (m_outputNonZero(a1) > 0 &&
            m_dataFormatTypeAvailableFlag(a1))
        {
            m_outputStdErrTemp(a1) = std::sqrt(m_outputStdErrTemp(a1));
            m_outputPrecisionTemp80(a1) = constants::ZVAL80 * m_outputStdErrTemp(a1);

            m_outputPrecisionTemp80(a1) = constants::ZVAL80 * m_outputStdErrTemp(a1);
            m_outputLowerLimitTemp80(a1) = m_outputPNTestTemp(a1) - m_outputPrecisionTemp80(a1);
            m_outputUpperLimitTemp80(a1) = m_outputPNTestTemp(a1) + m_outputPrecisionTemp80(a1);

            m_outputPrecisionTemp90(a1) = constants::ZVAL90 * m_outputStdErrTemp(a1);
            m_outputLowerLimitTemp90(a1) = m_outputPNTestTemp(a1) - m_outputPrecisionTemp90(a1);
            m_outputUpperLimitTemp90(a1) = m_outputPNTestTemp(a1) + m_outputPrecisionTemp90(a1);

            m_outputPrecisionTemp95(a1) = constants::ZVAL95 * m_outputStdErrTemp(a1);
            m_outputLowerLimitTemp95(a1) = m_outputPNTestTemp(a1) - m_outputPrecisionTemp95(a1);
            m_outputUpperLimitTemp95(a1) = m_outputPNTestTemp(a1) + m_outputPrecisionTemp95(a1);

            m_outputVStdErr(a1) = m_outputStdErrTemp(a1);
            m_outputVProjectNumber(a1) = m_outputPNTest(a1);
            m_outputVLowerLimit80(a1) = m_outputLowerLimitTemp80(a1);
            m_outputVLowerLimit90(a1) = m_outputLowerLimitTemp90(a1);
            m_outputVLowerLimit95(a1) = m_outputLowerLimitTemp95(a1);
            m_outputVUpperLimit80(a1) = m_outputUpperLimitTemp80(a1);
            m_outputVUpperLimit90(a1) = m_outputUpperLimitTemp90(a1);
            m_outputVUpperLimit95(a1) = m_outputUpperLimitTemp95(a1);
            m_outputVPrecision80(a1) = m_outputPrecisionTemp80(a1);
            m_outputVPrecision90(a1) = m_outputPrecisionTemp90(a1);
            m_outputVPrecision95(a1) = m_outputPrecisionTemp95(a1);
        }
    }
}
}}}}//end namespace

