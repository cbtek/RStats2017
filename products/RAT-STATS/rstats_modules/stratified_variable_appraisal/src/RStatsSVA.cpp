/*
    RStatsSVA.cpp
    

*/
//----------------------------------------
//RStatsSVA.cpp generated by CBTek Solutions on 01-28-2017 at 10:02:20 PM
//----------------------------------------

#include "RStatsSVA.h"
#include "rstats_utils/inc/RStatsObjectList.hpp"
#include "rstats_utils/inc/RStatsUtils.hpp"

#include "utility/inc/Exception.hpp"
#include "utility/inc/StringUtils.hpp"

#include <vector>
#include <cmath>

using namespace oig::ratstats::utils;
using namespace cbtek::common::utility;

namespace oig {
namespace ratstats {
namespace modules {
namespace sva {

CREATE_EXCEPTION_NO_MSG(RStatsSVAException)

namespace constants
{
    const static RStatsFloat ZVAL80 = 1.281551565545;
    const static RStatsFloat ZVAL90 = 1.644853626951;
    const static RStatsFloat ZVAL95 = 1.95996398454;
}

RStatsSVAOutputDataList RStatsSVA::execute(const std::string& auditName,
                                           const RStatsWorksheet &dataSheet,
                                           const RStatsWorksheet &sizeSheet,
                                           const RStatsDataFormatTypeIndex & dataSheetIndex,
                                           size_t dataSheetRowStart,
                                           size_t sizeSheetSampleSizeColumn,
                                           size_t sizeSheetUniverseSizeColumn,
                                           size_t sizeSheetRowStart)
{
    RStatsSVAInputDataList strataDataList = buildInputDataList(dataSheet,
                                                               sizeSheet,
                                                               dataSheetIndex,
                                                               dataSheetRowStart,
                                                               sizeSheetSampleSizeColumn,
                                                               sizeSheetUniverseSizeColumn,
                                                               sizeSheetRowStart);
    RStatsDataFormatType dataFormatType;
    RStatsInteger index = 0;    
    m_summaryTotalSum = 0.;
    m_summaryPopulationSize = 0;
    m_summarySampleSize = 0;
    m_summaryNonZero = 0;
    m_summaryPointEstimate = 0.;
    m_summaryStandardErrorMean = 0.;
    m_summaryStandardErrorTotal = 0.;
    m_summaryLowerLimit80 = 0.;
    m_summaryLowerLimit90 = 0.;
    m_summaryLowerLimit95 = 0.;
    m_summaryUpperLimit80 = 0.;
    m_summaryUpperLimit90 = 0.;
    m_summaryUpperLimit95 = 0.;
    m_summaryPrecisionAmount80 = 0.;
    m_summaryPrecisionAmount90 = 0.;
    m_summaryPrecisionAmount95 = 0.;
    m_summaryPrecisionPercent80 = 0.;
    m_summaryPrecisionPercent90 = 0.;
    m_summaryPrecisionPercent95 = 0.;
    m_summaryZValue80 = 0.;
    m_summaryZValue90 = 0.;
    m_summaryZValue95 = 0.;
    m_summaryTValue80 = 0.;
    m_summaryTValue90 = 0.;
    m_summaryTValue95 = 0.;
    m_summaryStandardDeviation = 0.;
    m_auditName = auditName;
    m_currentIndex = 0;
    for (const RStatsSVAInputData& inputData : strataDataList)
    {
        onReset();
        dataFormatType = inputData.typeIndex.type;
        m_currentNonZero = static_cast<RStatsInteger>(RStatsUtils::getNumItemsThatMatchCondition<RStatsFloat>(RStatsConditionalOperatorType::NotEqual,
                                                                                inputData.samples,
                                                                                0.));
        m_examValues.clear();
        m_auditValues.clear();
        m_differenceValues.clear();
        initializeDataTypeFormat(dataFormatType, inputData);
        calculateMean(inputData);
        calculatePointEstimates(inputData);
        calculateCorrectionFactors(inputData);
        calculateDegreesOfFreedom(inputData);
        calculateStandardDeviation(inputData);
        calculateStandardError(inputData);
        calculateSamplingError(inputData);
        calculateIntervals(inputData);

        m_summarySampleSize += inputData.sampleSize;
        m_summaryNonZero += RStatsUtils::getSum(m_outputNonZero);
        m_summaryTotalSum += RStatsUtils::getSum(m_outputSum);
        m_summaryPopulationSize += inputData.universeSize;

        buildOutputData(m_outputDataList,
                        inputData,
                        dataFormatType);
        ++index;
        m_currentIndex = index;
    }    
    processSummaryTotals(m_outputDataList);
    return m_outputDataList;
}


void RStatsSVA::saveToWorkbook(RStatsWorkbook &workbookOut)
{    
    RStatsSVAOutputDataList &outputList = m_outputDataList;
    RStatsInteger counter = 1;
    for(const RStatsSVAOutputData& data : outputList)
    {
        RStatsWorksheet sheet;        
        std::string title;
        if (data.isDisplaySummary)
        {
            title = "Summary";
        }
        else
        {
            title = "Stratum "+std::to_string(counter);
        }
        sheet.setDefaultTextAlignment(RStatsTextAlignment::AlignRight);
        sheet.setWorksheetTitle(title);
        sheet.setDefaultFont(cbtek::common::utility::Font("arial",11,true));

        sheet("A1")= "Audit Name:";
        sheet("A2")= "Universe Size:";
        sheet("A3")= "Sample Size:";
        sheet("A4")= "Nonzero Count:";
        sheet("A5")= "Creation Date:";
        sheet("A6")= "Creation Time:";
        sheet("A7")= "Created By:";

        sheet("C1")="Mean:";        
        sheet("C2")="Skewnewss:";
        sheet("C3")="Kurtosis:";
        sheet("C4")="Std. Deviation:";
        sheet("C5")="Std. Err. Mean:";
        sheet("C6")="Std. Err. Total:";
        sheet("C7")="Point Estimate:";

        sheet("A11") = "Lower:";
        sheet("A12") = "Upper:";
        sheet("A13")="Precision Amount:";
        sheet("A14")="Precision Percent:";

        sheet.setDefaultTextAlignment(RStatsTextAlignment::AlignMiddle);
        sheet("C9") = "Confidence Levels";
        sheet("B10") = "80%";
        sheet("C10") = "90%";
        sheet("D10") = "95%";
        sheet("B10").bgColor.set(255,127,127);
        sheet("C10").bgColor.set(255,255,127);
        sheet("D10").bgColor.set(127,255,127);
        sheet("B10").fgColor.set(1,1,1);
        sheet("C10").fgColor.set(1,1,1);
        sheet("D10").fgColor.set(1,1,1);
        sheet.setDefaultTextAlignment(RStatsTextAlignment::AlignLeft);
        sheet("B1") = m_auditName;
        sheet("B2") = data.populationSize;
        sheet("B3") = data.sampleSize;
        sheet("B4") = data.nonZeroCount;
        sheet("B5") = DateUtils::toLongDateString(DateUtils::getCurrentDate());
        sheet("B6") = TimeUtils::to12HourTimeString(TimeUtils::getCurrentTime());
        sheet("B7") = SystemUtils::getUserName();

        sheet("D1") = StringUtils::toString(data.mean,2);
        sheet("D2") = StringUtils::toString(data.skewness,2);
        sheet("D3") = StringUtils::toString(data.kurtosis,2);
        sheet("D4") = StringUtils::toString(data.standardDeviation,2);
        sheet("D5") = StringUtils::toString(data.standardErrorMean,2);
        sheet("D6") = StringUtils::toString(data.standardErrorTotal,0);
        sheet("D7") = StringUtils::toString(data.pointEstimate,0);
        sheet.resetDefaults();
        sheet.setDefaultTextAlignment(RStatsTextAlignment::AlignMiddle);
        sheet.setDefaultFont(Font("arial",11));
        sheet.setDefaultFloatingPointDecimals(2);
        sheet.setDefaultFloatingPointDecimals(0);

        std::string percent80 = StringUtils::toString(data.precisionPercent80*100.,2)+"%";
        std::string percent90 = StringUtils::toString(data.precisionPercent90*100.,2)+"%";
        std::string percent95 = StringUtils::toString(data.precisionPercent95*100.,2)+"%";

        sheet("B11") = data.lower80;
        sheet("C11") = data.lower90;
        sheet("D11") = data.lower95;

        sheet("B12") = data.upper80;
        sheet("C12") = data.upper90;
        sheet("D12") = data.upper95;

        sheet("B13") = data.precisionAmount80;
        sheet("C13") = data.precisionAmount90;
        sheet("D13") = data.precisionAmount95;

        sheet("B14") = percent80;
        sheet("C14") = percent90;
        sheet("D14") = percent95;

        if (data.isDisplaySummary)
        {

            sheet("C1")="";
            sheet("C2")="";
            sheet("C3")="";
            sheet("C4")="";
            sheet("D1")="";
            sheet("D2")="";
            sheet("D3")="";
            sheet("D4")="";
            sheet.setDefaultTextAlignment(RStatsTextAlignment::AlignRight);
            sheet.setDefaultFont(cbtek::common::utility::Font("arial",11,true));
            sheet("A15") = "z-Value:";
            sheet.setDefaultFloatingPointDecimals(12);
            sheet.setDefaultTextAlignment(RStatsTextAlignment::AlignMiddle);
            sheet("B15") = data.tValue80;
            sheet("C15") = data.tValue90;
            sheet("D15") = data.tValue95;
        }
        else
        {
            sheet.setDefaultTextAlignment(RStatsTextAlignment::AlignRight);
            sheet.setDefaultFont(cbtek::common::utility::Font("arial",11,true));
            sheet("A15") = "t-Value:";
            sheet.setDefaultFloatingPointDecimals(12);
            sheet.setDefaultTextAlignment(RStatsTextAlignment::AlignMiddle);
            sheet("B15") = data.tValue80;
            sheet("C15") = data.tValue90;
            sheet("D15") = data.tValue95;
        }
        workbookOut.addWorksheet(sheet);
        if (!data.isDisplaySummary)
        {
            ++counter;
        }
    }
}

void RStatsSVA::buildOutputData(RStatsSVAOutputDataList& outputDataList,
                                const RStatsSVAInputData& inputData,
                                RStatsDataFormatType type)
{
    if (type == RStatsDataFormatType::Examine ||
        type == RStatsDataFormatType::ExamineAndAudit||
        type == RStatsDataFormatType::ExamineAndDifference)
    {
        RStatsSVAOutputData examine;
        copyOutputData(examine,inputData,type,0);
        outputDataList.push_back(examine);
    }

    if (type == RStatsDataFormatType::Audit ||
        type == RStatsDataFormatType::AuditAndDifference ||
        type == RStatsDataFormatType::ExamineAndAudit)
    {
        RStatsSVAOutputData audit;
        copyOutputData(audit,inputData,type,1);
        outputDataList.push_back(audit);
    }

    if (type == RStatsDataFormatType::Difference ||
        type == RStatsDataFormatType::AuditAndDifference ||
        type == RStatsDataFormatType::ExamineAndDifference)
    {
        RStatsSVAOutputData difference;
        copyOutputData(difference,inputData,type,2);
        outputDataList.push_back(difference);
    }

}


void RStatsSVA::copyOutputData(RStatsSVAOutputData& outputData,
                               const RStatsSVAInputData& inputData,
                               RStatsDataFormatType type,
                               size_t dataFormatIndex)
{
    outputData.auditName = m_auditName;
    outputData.type = type;
    outputData.sampleSize = inputData.sampleSize;
    outputData.populationSize = inputData.universeSize;
    outputData.nonZeroCount = static_cast<RStatsInteger>(m_outputNonZero(dataFormatIndex));
    outputData.mean = m_outputMean(dataFormatIndex);
    outputData.standardDeviation = m_outputStdDev(dataFormatIndex);
    outputData.skewness = m_outputSkewAmount(dataFormatIndex);
    outputData.standardErrorMean = m_outputStdErr(dataFormatIndex);
    outputData.standardErrorTotal = m_outputStdErr(dataFormatIndex) * inputData.universeSize;
    outputData.pointEstimate = m_outputPNTest(dataFormatIndex);
    outputData.lower80 = m_outputLowerLimit80(dataFormatIndex);
    outputData.lower90 = m_outputLowerLimit90(dataFormatIndex);
    outputData.lower95 = m_outputLowerLimit95(dataFormatIndex);
    outputData.upper80 = m_outputUpperLimit80(dataFormatIndex);
    outputData.upper90 = m_outputUpperLimit90(dataFormatIndex);
    outputData.upper95 = m_outputUpperLimit95(dataFormatIndex);
    outputData.kurtosis = m_outputKurtosisAmount(dataFormatIndex);
    outputData.createDate = DateUtils::getCurrentDate();
    outputData.createTime = TimeUtils::getCurrentTime();
    outputData.precisionAmount80 = m_outputPrecision80(dataFormatIndex) * inputData.universeSize;
    outputData.precisionAmount90 = m_outputPrecision90(dataFormatIndex) * inputData.universeSize;
    outputData.precisionAmount95 = m_outputPrecision95(dataFormatIndex) * inputData.universeSize;

    if (outputData.mean > 0)
    {
        outputData.precisionPercent80 = m_outputPrecision80(dataFormatIndex) / outputData.mean;
        outputData.precisionPercent90 = m_outputPrecision90(dataFormatIndex) / outputData.mean;
        outputData.precisionPercent95 = m_outputPrecision95(dataFormatIndex) / outputData.mean;
    }

    outputData.tValue80 = m_outputTValue80;
    outputData.tValue90 = m_outputTValue90;
    outputData.tValue95 = m_outputTValue95;

}

RStatsSVA::RStatsSVA()
{
    m_totalSampleSize = 0;
    onReset();
}

RStatsSVA::~RStatsSVA()
{

}

RStatsSVAInputDataList RStatsSVA::buildInputDataList(const RStatsWorksheet &dataSheet,
                                                     const RStatsWorksheet &sizeSheet,
                                                     const RStatsDataFormatTypeIndex &dataSheetIndex,
                                                     size_t dataSheetRowStart,
                                                     size_t sizeSheetSampleSizeColumn,
                                                     size_t sizeSheetUniverseSizeColumn,
                                                     size_t sizeSheetRowStart)
{

    RStatsSVAInputDataList dataList;
    size_t dataRowOffset = dataSheetRowStart;
    for (size_t r = sizeSheetRowStart; r < sizeSheet.getNumRows(); ++r)
    {
        RStatsSVAInputData stratum;

        //Read size info for stratum
        std::string universeSize = sizeSheet(r,sizeSheetUniverseSizeColumn).text;
        std::string sampleSize = sizeSheet(r,sizeSheetSampleSizeColumn).text;

        stratum.universeSize = StringUtils::toInt(universeSize);
        stratum.sampleSize = StringUtils::toInt(sampleSize);
        stratum.offset = static_cast<RStatsInteger>(dataRowOffset);
        stratum.typeIndex = dataSheetIndex;
        bool isMultiDataFormat = (stratum.typeIndex.type == RStatsDataFormatType::AuditAndDifference ||
                                  stratum.typeIndex.type == RStatsDataFormatType::ExamineAndAudit ||
                                  stratum.typeIndex.type == RStatsDataFormatType::ExamineAndDifference);

        stratum.samples.initialize(static_cast<size_t>(stratum.sampleSize),(isMultiDataFormat)?2:1);
        size_t index = 0;
        //For each stratum lets grab the data samples
        for (RStatsInteger a1 = 0; a1 < stratum.sampleSize;++a1)
        {
            std::string value1 = dataSheet(static_cast<size_t>(a1+stratum.offset),
                                           stratum.typeIndex.primaryIndex).text;
            StringUtils::removeInPlace(value1,",");
            StringUtils::removeInPlace(value1,"$");
            stratum.samples(index,0) = StringUtils::toFloat64(value1);
            std::string value2;
            if (isMultiDataFormat)
            {
                value2 = dataSheet(static_cast<size_t>(a1+stratum.offset),
                                   stratum.typeIndex.secondaryIndex).text;
                StringUtils::removeInPlace(value2,",");
                StringUtils::removeInPlace(value2,"$");
                stratum.samples(index,1) = StringUtils::toFloat64(value2);
            }
            ++index;
            ++dataRowOffset;
        }
        dataList.push_back(stratum);
    }
    return dataList;
}

void RStatsSVA::onReset()
{
    m_temporary80 = 0.;
    m_temporary90 = 0.;
    m_temporary95 = 0.;
    m_outputTValue80 = 0.;
    m_outputTValue90 = 0.;
    m_outputTValue95 = 0.;
    m_formulaVarA = 0.;
    m_formulaVarB = 0.;
    m_formulaVarT = 0.;
    m_formulaVarPI = 0.;
    m_formulaVarX = 0.;
    m_formulaVarC0 = 0.;
    m_frontValue = 0.;
    m_eps = 0.;
    m_outputDOF = 0.;
    m_outputSEFIN = 0.;
    m_formulaVarTLast = 0.;
    m_lowValue = 0.;
    m_highValue = 0.;
    m_newProbability = 0.;
    m_lowProbability = 0.;
    m_highProbability = 0.;
    m_difference = 0.;
    m_cumaltiveProbability = 0.;
    m_currentProbability = 0.;
    m_temporary80 = 0.;
    m_temporary90 = 0.;
    m_temporary95 = 0.;
    m_lastLogValue = 0.;
    m_logValue1 = 0.;
    m_logValue2 = 0.;
    m_logValue3 = 0.;
    m_logValue4 = 0.;
    m_totalAmount = 0.;
    m_examineSum = 0.;
    m_auditSum = 0.;
    m_differenceSum = 0.;
    m_dataFormatTypeAvailableFlag.initialize(3);
    m_outputNonZero.initialize(3);
    m_outputSkewAmount.initialize(3);
    m_outputSkewVAmount.initialize(3);
    m_outputKurtosisAmount.initialize(3);
    m_outputKurtosisVAmount.initialize(3);
    m_valuesC.initialize(1000);
    m_outputSum.initialize(3);
    m_outputSumSqrt.initialize(3);
    m_outputSumCbrt.initialize(3);
    m_outputSumQdrt.initialize(3);
    m_examValues.initialize(3);
    m_auditValues.initialize(3);
    m_differenceValues.initialize(3);
    m_outputMean.initialize(3);
    m_outputPrecision80.initialize(3);
    m_outputPrecision90.initialize(3);
    m_outputPrecision95.initialize(3);
    m_outputVPrecision80.initialize(3);
    m_outputVPrecision90.initialize(3);
    m_outputVPrecision95.initialize(3);
    m_outputPNTest.initialize(3);
    m_outputPNTestTemp.initialize(3);
    m_outputVMean.initialize(3);
    m_outputVProjectNumber.initialize(3);
    m_outputStdDev.initialize(3);
    m_outputStdErr.initialize(3);
    m_outputVStdDev.initialize(3);
    m_outputTermSE.initialize(3);
    m_outputStdDevTemp.initialize(3);
    m_outputStdErrTemp.initialize(3);
    m_outputUpperLimit80.initialize(3);
    m_outputUpperLimit90.initialize(3);
    m_outputUpperLimit95.initialize(3);
    m_outputLowerLimit80.initialize(3);
    m_outputLowerLimit90.initialize(3);
    m_outputLowerLimit95.initialize(3);
    m_outputVUpperLimit80.initialize(3);
    m_outputVUpperLimit90.initialize(3);
    m_outputVUpperLimit95.initialize(3);
    m_outputVLowerLimit80.initialize(3);
    m_outputVLowerLimit90.initialize(3);
    m_outputVLowerLimit95.initialize(3);
    m_outputUpperLimitTemp80.initialize(3);
    m_outputUpperLimitTemp90.initialize(3);
    m_outputUpperLimitTemp95.initialize(3);
    m_outputLowerLimitTemp80.initialize(3);
    m_outputLowerLimitTemp90.initialize(3);
    m_outputLowerLimitTemp95.initialize(3);
    m_outputPrecisionTemp80.initialize(3);
    m_outputPrecisionTemp90.initialize(3);
    m_outputPrecisionTemp95.initialize(3);
    m_outputVStdErr.initialize(3);
    m_outputNonZeroTemp.initialize(3);

    m_currentIteration = 0;
    m_currentNonZero = 0;
    m_examineZeroCount = 0;
    m_auditZeroCount = 0;
    m_differenceZeroCount = 0;
    m_outputNonZeroSize = 0;
    m_numTerms = 0;
    m_maxIterations = 0;
    m_numStrata = 0;
    m_conditionCount = 0;
    m_conditionUsage = 0;
}

void RStatsSVA::onUpdateSums(const RStatsFloatList &auditValues,
                             const RStatsFloatList &examValues,
                             const RStatsFloatList &differenceValues
                            )
{

    m_outputSum(0) += RStatsUtils::getSum(examValues);
    m_outputSumSqrt(0) += RStatsUtils::getSumRaisedTo<RStatsFloat>(examValues,2);
    m_outputSumCbrt(0) += RStatsUtils::getSumRaisedTo<RStatsFloat>(examValues,3);
    m_outputSumQdrt(0) += RStatsUtils::getSumRaisedTo<RStatsFloat>(examValues,4);
    m_outputNonZero(0) += RStatsUtils::getNumItemsThatMatchCondition(RStatsConditionalOperatorType::NotEqual,
                                                                     examValues,
                                                                     0.);

    m_outputSum(1) += RStatsUtils::getSum(auditValues);
    m_outputSumSqrt(1) += RStatsUtils::getSumRaisedTo<RStatsFloat>(auditValues,2);
    m_outputSumCbrt(1) += RStatsUtils::getSumRaisedTo<RStatsFloat>(auditValues,3);
    m_outputSumQdrt(1) += RStatsUtils::getSumRaisedTo<RStatsFloat>(auditValues,4);
    m_outputNonZero(1) += RStatsUtils::getNumItemsThatMatchCondition(RStatsConditionalOperatorType::NotEqual,
                                                                     auditValues,
                                                                     0.);

    m_outputSum(2) += RStatsUtils::getSum(differenceValues);
    m_outputSumSqrt(2) += RStatsUtils::getSumRaisedTo<RStatsFloat>(differenceValues,2);
    m_outputSumCbrt(2) += RStatsUtils::getSumRaisedTo<RStatsFloat>(differenceValues,3);
    m_outputSumQdrt(2) += RStatsUtils::getSumRaisedTo<RStatsFloat>(differenceValues,4);
    m_outputNonZero(2) += RStatsUtils::getNumItemsThatMatchCondition(RStatsConditionalOperatorType::NotEqual,
                                                                     differenceValues,
                                                                     0.);

}


void RStatsSVA::initializeDataTypeFormat(RStatsDataFormatType dataTypeFormat,
                                         const RStatsSVAInputData& inputData)
{

    if (dataTypeFormat == RStatsDataFormatType::Examine)
    {
        m_examineZeroCount = RStatsUtils::getNumItemsThatMatchCondition(RStatsConditionalOperatorType::NotEqual,
                                                                        inputData.samples,
                                                                        0.0,
                                                                        0);
        m_dataFormatTypeAvailableFlag(0) = true;
        m_examineSum = RStatsUtils::getSum(inputData.samples);
        m_outputSum(0) += m_examineSum;        
        m_outputSumSqrt(0) += RStatsUtils::getSumRaisedTo<RStatsFloat>(inputData.samples,2);
        m_outputSumCbrt(0) += RStatsUtils::getSumRaisedTo<RStatsFloat>(inputData.samples,3);
        m_outputSumQdrt(0) += RStatsUtils::getSumRaisedTo<RStatsFloat>(inputData.samples,4);
        m_outputNonZero(0) += m_examineZeroCount;
    }
    else if (dataTypeFormat == RStatsDataFormatType::Audit)
    {
        m_auditZeroCount = RStatsUtils::getNumItemsThatMatchCondition(RStatsConditionalOperatorType::NotEqual,
                                                                      inputData.samples,
                                                                      0.0,
                                                                      0);
        m_dataFormatTypeAvailableFlag(1) = true;
        m_auditSum = RStatsUtils::getSum(inputData.samples);
        m_outputSum(1) += m_auditSum;
        m_outputSumSqrt(1) += RStatsUtils::getSumRaisedTo<RStatsFloat>(inputData.samples,2);
        m_outputSumCbrt(1) += RStatsUtils::getSumRaisedTo<RStatsFloat>(inputData.samples,3);
        m_outputSumQdrt(1) += RStatsUtils::getSumRaisedTo<RStatsFloat>(inputData.samples,4);
        m_outputNonZero(1) += m_auditZeroCount;

    }
    else if (dataTypeFormat == RStatsDataFormatType::Difference)
    {
        m_differenceZeroCount = RStatsUtils::getNumItemsThatMatchCondition(RStatsConditionalOperatorType::NotEqual,
                                                                           inputData.samples,
                                                                           0.0,
                                                                           0);
        m_dataFormatTypeAvailableFlag(2) = true;
        m_differenceSum = RStatsUtils::getSum(inputData.samples);
        m_outputSum(2) += m_differenceSum;
        m_outputSumSqrt(2) += RStatsUtils::getSumRaisedTo<RStatsFloat>(inputData.samples,2);
        m_outputSumCbrt(2) += RStatsUtils::getSumRaisedTo<RStatsFloat>(inputData.samples,3);
        m_outputSumQdrt(2) += RStatsUtils::getSumRaisedTo<RStatsFloat>(inputData.samples,4);
        m_outputNonZero(2) += m_differenceZeroCount;

    }
    else if (dataTypeFormat == RStatsDataFormatType::ExamineAndAudit)
    {
        if (inputData.samples.getNumDimensions() > 1)
        {
            m_examValues.appendDimension(inputData.samples,0);
            m_auditValues.appendDimension(inputData.samples,1);
            m_differenceValues = RStatsUtils::getNumbersSubtracted(m_examValues,m_auditValues);
            m_examineSum = RStatsUtils::getSum(m_examValues);
            m_differenceSum = RStatsUtils::getSum(m_differenceValues);
            m_auditSum = RStatsUtils::getSum(m_auditValues);
            m_dataFormatTypeAvailableFlag(0) = true;
            m_dataFormatTypeAvailableFlag(1) = true;
            m_dataFormatTypeAvailableFlag(2) = true;

            onUpdateSums(m_auditValues,
                     m_examValues,
                     m_differenceValues);
        }
    }

    else if (dataTypeFormat == RStatsDataFormatType::ExamineAndDifference)
    {
        if (inputData.samples.getNumDimensions() > 1)
        {
            m_examValues.appendDimension(inputData.samples,0);
            m_differenceValues.appendDimension(inputData.samples,1);
            m_auditValues = RStatsUtils::getNumbersSubtracted(m_examValues,m_differenceValues);
            m_examineSum = RStatsUtils::getSum(m_examValues);
            m_differenceSum = RStatsUtils::getSum(m_differenceValues);
            m_auditSum = RStatsUtils::getSum(m_auditValues);

            m_dataFormatTypeAvailableFlag(0) = true;
            m_dataFormatTypeAvailableFlag(1) = true;
            m_dataFormatTypeAvailableFlag(2) = true;

            onUpdateSums(m_auditValues,
                     m_examValues,
                     m_differenceValues);

        }
    }

    else if (dataTypeFormat == RStatsDataFormatType::AuditAndDifference)
    {
        if (inputData.samples.getNumDimensions() > 1)
        {
            m_auditValues.appendDimension(inputData.samples,0);
            m_differenceValues.appendDimension(inputData.samples,1);
            m_examValues = RStatsUtils::getNumbersAdded(m_auditValues,m_differenceValues);
            m_examineSum = RStatsUtils::getSum(m_examValues);
            m_differenceSum = RStatsUtils::getSum(m_differenceValues);
            m_auditSum = RStatsUtils::getSum(m_auditValues);

            m_dataFormatTypeAvailableFlag(0) = true;
            m_dataFormatTypeAvailableFlag(1) = true;
            m_dataFormatTypeAvailableFlag(2) = true;

            onUpdateSums(m_auditValues,
                     m_examValues,
                     m_differenceValues);
        }
    }
}
//'---------CALCULATE MEAN--------
void RStatsSVA::calculateMean(const RStatsSVAInputData& inputData)
{
    for (RStatsInteger a1 = 0; a1 < 3; ++a1)
    {
        if (inputData.sampleSize > 0 &&
            m_currentNonZero > 0 &&
            m_dataFormatTypeAvailableFlag(a1))
        {
            m_outputMean(a1) = m_outputSum(a1) / (RStatsFloat)inputData.sampleSize;
            m_outputVMean(a1) = m_outputMean(a1);
        }
    }
}

//'----------CALCULATE STANDARD DEVIATION----------
void RStatsSVA::calculateStandardDeviation(const RStatsSVAInputData &inputData)
{
    for (RStatsInteger a1 = 0; a1 < 3; ++a1)
    {
        if (!RStatsUtils::isEqual<RStatsFloat>(m_outputSum(a1), 0.0) &&
            inputData.sampleSize > 1 &&
            m_dataFormatTypeAvailableFlag(a1))
        {
            RStatsFloat totalAmount = m_outputSum(a1);
            RStatsFloat sampleSize = inputData.sampleSize;
            RStatsFloat sqRt = m_outputSumSqrt(a1);
            RStatsFloat universeSize = inputData.universeSize;
            RStatsFloat temp1 = std::pow(totalAmount,2) / sampleSize;
            if (temp1 < sqRt)
            {
                m_outputStdDev(a1) = (std::sqrt((sqRt - temp1) / m_outputDOF));
            }
            else
            {
                m_outputStdDev(a1) = 0.;
            }
            m_outputStdDevTemp(a1) += (m_outputStdDevTemp(a1) + std::pow(m_outputStdDev(a1),2) * std::pow(universeSize,2));
            m_summaryStandardDeviation += m_outputStdDevTemp(a1);
        }
        m_outputVStdDev(a1) = m_outputStdDev(a1);
    }
}

//'----------CALCULATE STANDARD ERROR----------
void RStatsSVA::calculateStandardError(const RStatsSVAInputData& inputData)
{
    for (RStatsInteger a1 = 0; a1 < 3; ++a1)
    {
        if (!RStatsUtils::isEqual<RStatsFloat>(m_outputStdDev(a1), 0.0) &&
            inputData.sampleSize > 1 &&
            m_dataFormatTypeAvailableFlag(a1))
        {
            RStatsFloat stdDev = m_outputStdDev(a1);
            RStatsFloat sqrSampSize = std::sqrt(inputData.sampleSize);
            m_outputStdErr(a1) = (stdDev / sqrSampSize) * m_outputSEFIN;
            RStatsFloat tempValue = inputData.universeSize;
            tempValue *= (inputData.universeSize - inputData.sampleSize);
            tempValue *= (std::pow(m_outputStdDev(a1),2));
            tempValue /= (RStatsFloat) inputData.sampleSize;
            m_outputTermSE(a1) = tempValue;
            m_outputStdErrTemp(a1) += m_outputTermSE(a1);
            m_summaryStandardErrorMean += m_outputStdErrTemp(a1);
        }
    }
}

//'---------CALCULATE CORRECTION FACTORS-------
void RStatsSVA::calculateCorrectionFactors(const RStatsSVAInputData& inputData)
{
    if (inputData.universeSize > 1)
    {
        RStatsFloat value = static_cast<RStatsFloat>(inputData.universeSize - inputData.sampleSize) / (static_cast<RStatsFloat>(inputData.universeSize));
        m_outputSEFIN = std::sqrt(value);
    }
}

//'---------CALCULATE DEGREES OF FREEDOM-------
void RStatsSVA::calculateDegreesOfFreedom(const RStatsSVAInputData& inputData)
{
    m_outputDOF = inputData.sampleSize - 1;
}

//'----------CALCULATE POINT ESTIMATES------
void RStatsSVA::calculatePointEstimates(const RStatsSVAInputData& inputData)
{
    for (RStatsInteger a1 = 0; a1 < 3; ++a1)
    {
        m_outputPNTest(a1) = m_outputMean(a1) * (RStatsFloat)inputData.universeSize;
        m_outputPNTestTemp(a1) = m_outputPNTestTemp(a1) + m_outputPNTest(a1);
        m_summaryPointEstimate += m_outputPNTest(a1);
        m_outputVProjectNumber(a1) = m_outputPNTest(a1);
    }
}

//'----------CALCULATE LOWER AND UPPER LIMITS-----------
void RStatsSVA::calculateUpperAndLowerLimits(const RStatsSVAInputData& inputData)
{
    for (size_t a1 = 0; a1 < 3; ++a1)
    {
        if (m_outputNonZero(a1) > 0)
        {
            RStatsFloat temp0 = m_outputPrecision80(a1) * static_cast<RStatsFloat>(inputData.universeSize);
            RStatsFloat temp1 = m_outputPrecision90(a1) * static_cast<RStatsFloat>(inputData.universeSize);
            RStatsFloat temp2 = m_outputPrecision95(a1) * static_cast<RStatsFloat>(inputData.universeSize);

            m_outputLowerLimit80(a1) = m_outputPNTest(a1) - temp0;
            m_outputLowerLimit90(a1) = m_outputPNTest(a1) - temp1;
            m_outputLowerLimit95(a1) = m_outputPNTest(a1) - temp2;

            m_outputUpperLimit80(a1) = m_outputPNTest(a1) + temp0;
            m_outputUpperLimit90(a1) = m_outputPNTest(a1) + temp1;
            m_outputUpperLimit95(a1) = m_outputPNTest(a1) + temp2;

            m_outputVUpperLimit80(a1) = m_outputUpperLimit80(a1);
            m_outputVLowerLimit80(a1) = m_outputLowerLimit80(a1);

            m_outputVLowerLimit90(a1) = m_outputLowerLimit90(a1);
            m_outputVUpperLimit90(a1) = m_outputUpperLimit90(a1);

            m_outputVLowerLimit95(a1) = m_outputLowerLimit95(a1);
            m_outputVUpperLimit95(a1) = m_outputUpperLimit95(a1);
        }
    }
}

//'----------CALCULATE SKEWNESS-----------
void RStatsSVA::calculateSkewness(const RStatsSVAInputData& inputData)
{
    for (RStatsInteger a1 = 0; a1 < 3; ++a1)
    {
        if (inputData.sampleSize > 0 &&
            m_currentNonZero > 0 &&
            m_dataFormatTypeAvailableFlag(a1))
        {
            RStatsFloat temp1 = m_outputSumCbrt(a1) / inputData.sampleSize;
            temp1 -= (3 * (m_outputSumSqrt(a1) / inputData.sampleSize) * m_outputMean(a1));
            temp1 += (2 * std::pow(m_outputMean(a1),3));
            RStatsFloat temp2;
            if (m_outputSumSqrt(a1) / inputData.sampleSize > std::pow(m_outputMean(a1),2))
            {
                temp2 = std::sqrt(m_outputSumSqrt(a1) / inputData.sampleSize - (std::pow(m_outputMean(a1),2)));
            }
            else
            {
                temp2 = 0;
            }
            if (temp2 > 1 || RStatsUtils::isEqual<RStatsFloat>(temp2, 1.))
            {
                m_outputSkewAmount(a1) = temp1 / std::pow(temp2,3);
            }
        }
        m_outputSkewVAmount(a1) = m_outputSkewAmount(a1);
    }
}

//'----------CALCULATE KURTOSIS-------------
void RStatsSVA::calculateKurtosis(const RStatsSVAInputData& inputData)
{
    for (RStatsInteger a1 = 0; a1 < 3; ++a1)
    {
        if (inputData.sampleSize > 0 &&
            m_currentNonZero > 0 &&
            m_dataFormatTypeAvailableFlag(a1))
        {
            RStatsFloat cubeRt = m_outputSumCbrt(a1);
            RStatsFloat quadRt = m_outputSumQdrt(a1);
            RStatsFloat sqRt = m_outputSumSqrt(a1);
            RStatsFloat sampSize = (RStatsFloat)inputData.sampleSize;
            RStatsFloat mean = m_outputMean(a1);

            RStatsFloat temp1 = quadRt / sampSize;
            temp1 -= (4 * (cubeRt / sampSize)) * mean;
            temp1 += (6 * (sqRt / sampSize) * std::pow(mean,2));
            temp1 -= (3 * std::pow(mean,4));
            RStatsFloat temp2 = 0.;
            if (sqRt / sampSize > std::pow(mean,2))
            {
                temp2 = std::sqrt(sqRt / sampSize - std::pow(mean,2));
            }
            else
            {
                temp2 = 0;
            }
            if (temp2 > 1 || RStatsUtils::isEqual<RStatsFloat>(temp2,1.))
            {
                m_outputKurtosisAmount(a1) = temp1 / std::pow(temp2,4);
            }
        }
        m_outputKurtosisVAmount(a1) = m_outputKurtosisAmount(a1);
    }
}

//'---------CALCULATE SAMPLING ERROR---------
void RStatsSVA::calculateSamplingError(const RStatsSVAInputData& inputData)
{
    m_temporary80 = 0.;
    m_temporary90 = 0.;
    m_temporary95 = 0.;
    if (m_outputDOF > 3)
    {
        processSamplingError(inputData);
    }
    else if (m_outputDOF == 1)
    {
        m_temporary80 = 3.077683537175;
        m_temporary90 = 6.313751514675;
        m_temporary95 = 12.706204736175;
    }
    else if (m_outputDOF == 2)
    {
        m_temporary80 = 1.885618083164;
        m_temporary90 = 2.919985580354;
        m_temporary95 = 4.30265272975;
    }
    else if (m_outputDOF == 3)
    {
        m_temporary80 = 1.637744353696;
        m_temporary90 = 2.353363434802;
        m_temporary95 = 3.182446305284;
    }
    calculateIntervals(inputData);
    //processSamplingError(inputData);
}

void RStatsSVA::processSamplingError(const RStatsSVAInputData& inputData)
{
    m_numTerms = 100;
    m_maxIterations = 1000;
    m_eps = 0.00000000000001;
    m_formulaVarA = 0.5;
    m_formulaVarB = m_outputDOF / 2;
    m_formulaVarPI = 4 * std::atan(1);
    m_conditionCount = 0;
    processConditionLoop(inputData);
}

void RStatsSVA::processConditionLoop(const RStatsSVAInputData& inputData)
{
    m_conditionCount++;
    m_lowValue = 0;
    m_highValue = 4;

    if (m_conditionCount == 1)
    {
        m_conditionUsage = 80;
    }
    else if (m_conditionCount == 2)
    {
        m_conditionUsage = 90;
    }
    else if (m_conditionCount == 3)
    {
        m_conditionUsage = 95;
    }
    m_cumaltiveProbability = (RStatsFloat)m_conditionUsage / 200 + .5;

    m_formulaVarT = m_lowValue;
    processFindCumProb(inputData);
    m_lowProbability = m_currentProbability;

    m_formulaVarT = m_highValue;
    processFindCumProb(inputData);
    m_highProbability = m_currentProbability;

    m_currentIteration = 0;
    processStartLoop(inputData);
}

void RStatsSVA::processStartLoop(const RStatsSVAInputData& inputData)
{
    m_currentIteration++;
    m_formulaVarTLast = m_formulaVarT;
    m_formulaVarT = (m_lowValue + m_highValue) / 2;
    processFindCumProb(inputData);
    m_newProbability = m_currentIteration;
    if (m_currentProbability < m_cumaltiveProbability)
    {
        m_lowValue = m_formulaVarT;
    }
    else
    {
        m_highValue = m_formulaVarT;
    }

    m_difference = fabsl(m_formulaVarT - m_formulaVarTLast) - m_eps;
    if (m_difference < 0 || RStatsUtils::isEqual<RStatsFloat>(m_formulaVarT,0.))
    {
        if (m_conditionCount == 1)
        {
            m_temporary80 = m_formulaVarT;
        }
        else if (m_conditionCount == 2)
        {
            m_temporary90 = m_formulaVarT;
        }
        else if (m_conditionCount == 3)
        {
            m_temporary95 = m_formulaVarT;
        }
    }
    else
    {
        if (m_currentIteration < m_maxIterations)
        {
            processStartLoop(inputData);
        }
        else
        {
            throw RStatsSVAException(EXCEPTION_TAG_LINE+"Program was unable to determine a t-value");
        }
    }
    if (m_conditionCount < 3)
    {
        processConditionLoop(inputData);
    }
    else
    {
        calculateIntervals(inputData);
    }
}

void RStatsSVA::processFindCumProb(const RStatsSVAInputData& inputData)
{
    m_formulaVarX = std::pow(m_formulaVarT,2) / (std::pow(m_formulaVarT,2) + m_outputDOF);
    RStatsInteger numTermsTemp = 0;
    if (m_outputDOF == 2)
    {
        m_formulaVarC0 = 1;
        processFindTerms(inputData);
    }
    else if (m_outputDOF == 3)
    {
        m_formulaVarC0 = 4 / m_formulaVarPI;
        processFindTerms(inputData);
    }
    if ((m_outputDOF - 2 * (int)(m_outputDOF / 2) == 0))
    {
        m_formulaVarC0 = 1;
        numTermsTemp = m_outputDOF / 2 - 1;
        for (RStatsInteger a1 = 0; a1 < numTermsTemp; ++a1)
        {
            RStatsFloat temp = 2 * (a1+1) + 1;
            m_formulaVarC0 = (m_formulaVarC0 * temp) / (temp - 1);
        }
        processFindTerms(inputData);
    }
    else
    {
        m_formulaVarC0 = 4 / m_formulaVarPI;
        numTermsTemp = ((m_outputDOF - 1) / 2) - 1;
        for (RStatsInteger a1 = 0; a1 < numTermsTemp; ++a1)
        {
            RStatsFloat temp = 2 * (a1+1) + 2;
            m_formulaVarC0 = (m_formulaVarC0 * temp) / (temp - 1);
        }
    }
    processFindTerms(inputData);
}

void RStatsSVA::processFindTerms(const RStatsSVAInputData& inputData)
{
    m_frontValue = std::pow((1 - m_formulaVarX), m_formulaVarB) * std::pow(m_formulaVarX,m_formulaVarA);
    RStatsFloat tempValue = m_formulaVarC0;
    m_valuesC(0) = m_formulaVarC0;
    RStatsFloat logOld = std::log(m_valuesC(0));
    if (RStatsUtils::isEqual<RStatsFloat>(m_formulaVarX,0))
    {
        tempValue = 0;
        processFindProbVal(tempValue);
        return;
    }
    for (RStatsInteger a1 = 0; a1 < m_numTerms;++a1)
    {
        m_logValue1 = std::log((a1 + m_formulaVarA + m_formulaVarB) / (a1+1+m_formulaVarA));
        m_logValue2 = logOld;
        m_logValue3 = std::log(m_formulaVarX);
        m_logValue4 = m_logValue1 + m_logValue2 + (a1 + 1) * std::log(m_formulaVarX);
        logOld = m_logValue1 + m_logValue2;
        tempValue = tempValue + std::exp(m_logValue4);
    }
    processFindProbVal(tempValue);
}

void RStatsSVA::processFindProbVal(RStatsFloat tempValue)
{
    m_currentProbability = .5 * (m_frontValue * tempValue + 1);
}

void RStatsSVA::processSummaryTotals(RStatsSVAOutputDataList& outputData)
{
    int x = 0;
    RStatsSVAOutputData summary;
    summary.pointEstimate = m_summaryPointEstimate;
    summary.nonZeroCount = m_summaryNonZero;
    summary.sampleSize = m_summarySampleSize;
    summary.populationSize = m_summaryPopulationSize;
    summary.lower80 = m_summaryLowerLimit80;
    summary.lower90 = m_summaryLowerLimit90;
    summary.lower95 = m_summaryLowerLimit95;

    summary.upper80 = m_summaryUpperLimit80;
    summary.upper90 = m_summaryUpperLimit90;
    summary.upper95 = m_summaryUpperLimit95;

    summary.precisionAmount80 = m_summaryPrecisionAmount80;
    summary.precisionAmount90 = m_summaryPrecisionAmount90;
    summary.precisionAmount95 = m_summaryPrecisionAmount95;

    summary.precisionPercent80 = m_summaryPrecisionPercent80;
    summary.precisionPercent90 = m_summaryPrecisionPercent90;
    summary.precisionPercent95 = m_summaryPrecisionPercent95;

    summary.standardErrorMean = m_summaryStandardErrorMean;
    summary.standardErrorTotal = m_summaryStandardErrorTotal;
    summary.standardDeviation = m_summaryStandardDeviation;
    summary.isDisplaySummary = true;
    outputData.insert(outputData.begin()+0, summary);
}

void RStatsSVA::calculateIntervals(const RStatsSVAInputData & inputData)
{
    m_outputTValue80 = m_temporary80;
    m_outputTValue90 = m_temporary90;
    m_outputTValue95 = m_temporary95;

    for (RStatsInteger a1 = 0; a1 < 3; ++a1)
    {
        if (m_outputNonZero(a1) > 0)
        {
            m_outputPrecision80(a1) = m_temporary80 * m_outputStdErr(a1);
            m_outputPrecision90(a1) = m_temporary90 * m_outputStdErr(a1);
            m_outputPrecision95(a1) = m_temporary95 * m_outputStdErr(a1);
        }

        m_outputVPrecision80(a1) = m_outputPrecision80(a1) * (RStatsFloat)inputData.universeSize;
        m_outputVPrecision90(a1) = m_outputPrecision90(a1) * (RStatsFloat)inputData.universeSize;
        m_outputVPrecision95(a1) = m_outputPrecision95(a1) * (RStatsFloat)inputData.universeSize;
    }

    calculateUpperAndLowerLimits(inputData);
    calculateSkewness(inputData);
    calculateKurtosis(inputData);
    calculateOverallPrecision(inputData);
}

void RStatsSVA::calculateOverallPrecision(const RStatsSVAInputData &inputData)
{
    for (size_t a1 = 0; a1 < 3; ++a1)
    {
        if (m_outputNonZero(a1) > 0 &&
            m_dataFormatTypeAvailableFlag(a1))
        {
            m_outputStdErrTemp(a1) = std::sqrt(m_outputStdErrTemp(a1));
            m_outputPrecisionTemp80(a1) = constants::ZVAL80 * m_outputStdErrTemp(a1);           
            m_outputLowerLimitTemp80(a1) = m_outputPNTestTemp(a1) - m_outputPrecisionTemp80(a1);
            m_outputUpperLimitTemp80(a1) = m_outputPNTestTemp(a1) + m_outputPrecisionTemp80(a1);

            m_outputPrecisionTemp90(a1) = constants::ZVAL90 * m_outputStdErrTemp(a1);
            m_outputLowerLimitTemp90(a1) = m_outputPNTestTemp(a1) - m_outputPrecisionTemp90(a1);
            m_outputUpperLimitTemp90(a1) = m_outputPNTestTemp(a1) + m_outputPrecisionTemp90(a1);

            m_outputPrecisionTemp95(a1) = constants::ZVAL95 * m_outputStdErrTemp(a1);
            m_outputLowerLimitTemp95(a1) = m_outputPNTestTemp(a1) - m_outputPrecisionTemp95(a1);
            m_outputUpperLimitTemp95(a1) = m_outputPNTestTemp(a1) + m_outputPrecisionTemp95(a1);

            m_outputVStdErr(a1) = m_outputStdErrTemp(a1);
            m_outputVProjectNumber(a1) = m_outputPNTest(a1);

            m_outputVLowerLimit80(a1) = m_outputLowerLimitTemp80(a1);
            m_outputVLowerLimit90(a1) = m_outputLowerLimitTemp90(a1);
            m_outputVLowerLimit95(a1) = m_outputLowerLimitTemp95(a1);
            m_outputVUpperLimit80(a1) = m_outputUpperLimitTemp80(a1);
            m_outputVUpperLimit90(a1) = m_outputUpperLimitTemp90(a1);
            m_outputVUpperLimit95(a1) = m_outputUpperLimitTemp95(a1);
            m_outputVPrecision80(a1) = m_outputPrecisionTemp80(a1);
            m_outputVPrecision90(a1) = m_outputPrecisionTemp90(a1);
            m_outputVPrecision95(a1) = m_outputPrecisionTemp95(a1);
        }
    }
}
}}}}//end namespace

