/*
    RStatsSVA.cpp
    

*/
//----------------------------------------
//RStatsSVA.cpp generated by CBTek Solutions on 01-28-2017 at 10:02:20 PM
//----------------------------------------

#include "RStatsSVA.h"
#include "rstats_utils/inc/RStatsObjectList.hpp"
#include "rstats_utils/inc/RStatsUtils.hpp"

#include "utility/inc/Exception.hpp"
#include "utility/inc/StringUtils.hpp"

#include <vector>
#include <cmath>

using namespace oig::ratstats::utils;
using namespace cbtek::common::utility;

namespace oig {
namespace ratstats {
namespace modules {
namespace sva {


namespace constants
{
    const static RStatsFloat ZVAL80 = 1.281551565545;
    const static RStatsFloat ZVAL90 = 1.644853626951;
    const static RStatsFloat ZVAL95 = 1.95996398454;
    const static size_t EXAMINE = 0;
    const static size_t AUDIT = 1;
    const static size_t DIFF = 2;
}

RStatsSVAOutputDataList RStatsSVA::execute(const std::string& auditName,
                                           const RStatsWorksheet &dataSheet,
                                           const RStatsWorksheet &sizeSheet,
                                           const RStatsDataFormatTypeIndex & dataSheetIndex,
                                           size_t dataSheetRowStart,
                                           size_t sizeSheetSampleSizeColumn,
                                           size_t sizeSheetUniverseSizeColumn,
                                           size_t sizeSheetRowStart)
{
    RStatsSVAInputDataList strataDataList = buildInputDataList(dataSheet,
                                                               sizeSheet,
                                                               dataSheetIndex,
                                                               dataSheetRowStart,
                                                               sizeSheetSampleSizeColumn,
                                                               sizeSheetUniverseSizeColumn,
                                                               sizeSheetRowStart);
    RStatsDataFormatType dataFormatType = RStatsDataFormatType::Audit;
    RStatsInteger index = 0;    
    m_summaryTotalSum = 0;
    m_summaryPopulationSize = 0;
    m_summarySampleSize  = 0;
    m_summaryNonZero = 0;
    m_summaryPointEstimate.initialize(3);
    m_summaryNonZeroCount.initialize(3);
    m_summaryLowerLimit80.initialize(3);
    m_summaryLowerLimit90.initialize(3);
    m_summaryLowerLimit95.initialize(3);
    m_summaryUpperLimit80.initialize(3);
    m_summaryUpperLimit90.initialize(3);
    m_summaryUpperLimit95.initialize(3);
    m_summaryPrecisionAmount80.initialize(3);
    m_summaryPrecisionAmount90.initialize(3);
    m_summaryPrecisionAmount95.initialize(3);
    m_summaryZValue80.initialize(3);
    m_summaryZValue90.initialize(3);
    m_summaryZValue95.initialize(3);
    m_summaryTValue80.initialize(3);
    m_summaryTValue90.initialize(3);
    m_summaryTValue95.initialize(3);
    m_summaryTotalMean.initialize(3);
    m_summaryStandardDeviation.initialize(3);
    m_auditName = auditName;
    m_currentIndex = 0;

    m_summaryStandardErrorMean.initialize(3);

    for (const RStatsSVAInputData& inputData : strataDataList)
    {
        onReset();
        dataFormatType = inputData.typeIndex.type;
        m_currentNonZero = static_cast<RStatsInteger>(RStatsUtils::getNumItemsThatMatchCondition<RStatsFloat>(RStatsConditionalOperatorType::NotEqual,
                                                                                inputData.samples,
                                                                                0.));

        m_examValues.clear();
        m_auditValues.clear();
        m_differenceValues.clear();
        initializeDataTypeFormat(dataFormatType, inputData);
        calculateMean(inputData);
        calculatePointEstimates(inputData);
        calculateCorrectionFactors(inputData);
        calculateDegreesOfFreedom(inputData);
        calculateStandardDeviation(inputData);
        calculateStandardError(inputData);
        calculateSamplingError(inputData);
        calculateIntervals(inputData);

        m_summarySampleSize += inputData.sampleSize;
        m_summaryNonZero += RStatsUtils::getSum(m_outputNonZero);
        m_summaryTotalSum += RStatsUtils::getSum(m_outputSum);
        m_summaryPopulationSize += inputData.universeSize;        
        buildOutputData(m_outputDataList,
                        inputData,
                        dataFormatType);
        ++index;
        m_currentIndex = index;        
    }    

    calculateOverallPrecision();
    RStatsSVAOutputDataTriplet summary;

    if (m_dataFormatTypeAvailableFlag(constants::EXAMINE))
    {
        summary.examine.typeName = "Examined Values (Summary)";
        processSummaryTotals(summary.examine,constants::EXAMINE);
    }
    if (m_dataFormatTypeAvailableFlag(constants::AUDIT))
    {
        summary.audit.typeName = "Audited Values (Summary)";
        processSummaryTotals(summary.audit,constants::AUDIT);
    }
    if (m_dataFormatTypeAvailableFlag(constants::DIFF))
    {
        summary.difference.typeName = "Difference Values (Summary)";
        processSummaryTotals(summary.difference,constants::DIFF);
    }


    m_outputDataList.insert(m_outputDataList.begin() + 0, summary);
    return m_outputDataList;
}

void RStatsSVA::processSummaryTotals(RStatsSVAOutputData& summary, size_t index)
{
    summary.isValid = true;
    summary.pointEstimate = m_summaryPointEstimate(index);
    summary.nonZeroCount = m_summaryNonZeroCount(index);
    summary.sampleSize = m_summarySampleSize;
    summary.populationSize = m_summaryPopulationSize;
    summary.lower80 = m_summaryLowerLimit80(index);
    summary.lower90 = m_summaryLowerLimit90(index);
    summary.lower95 = m_summaryLowerLimit95(index);

    summary.upper80 = m_summaryUpperLimit80(index);
    summary.upper90 = m_summaryUpperLimit90(index);
    summary.upper95 = m_summaryUpperLimit95(index);

    summary.tValue80 = constants::ZVAL80;
    summary.tValue90 = constants::ZVAL90;
    summary.tValue95 = constants::ZVAL95;

    summary.precisionAmount80 = m_summaryPrecisionAmount80(index);
    summary.precisionAmount90 = m_summaryPrecisionAmount90(index);
    summary.precisionAmount95 = m_summaryPrecisionAmount95(index);

    summary.precisionPercent80 =  RStatsUtils::isEqual(m_summaryPointEstimate(index),0.) ? 0. : 100. * (m_summaryPrecisionAmount80(index) / m_summaryPointEstimate(index));
    summary.precisionPercent90 =  RStatsUtils::isEqual(m_summaryPointEstimate(index),0.) ? 0. : 100. * (m_summaryPrecisionAmount90(index) / m_summaryPointEstimate(index));
    summary.precisionPercent95 =  RStatsUtils::isEqual(m_summaryPointEstimate(index),0.) ? 0. : 100. * (m_summaryPrecisionAmount95(index) / m_summaryPointEstimate(index));

    summary.standardErrorMean = m_summaryStandardErrorMean(index) / static_cast<RStatsFloat>(summary.populationSize);
    summary.standardErrorTotal = m_summaryStandardErrorMean(index);
    summary.standardDeviation = m_summaryStandardDeviation(index);
    summary.isDisplaySummary = true;
    summary.mean = m_summaryTotalMean(index);
}

void RStatsSVA::saveToWorkbook(RStatsWorkbook &workbookOut)
{    
    RStatsSVAOutputDataList &outputList = m_outputDataList;
    RStatsWorkbook summaryWorkbook;
    RStatsInteger counter = 1;
    for(const RStatsSVAOutputDataTriplet& data : outputList)
    {
        RStatsWorkbook stratumWorkbook;
        bool isSummary = false;
        if (data.examine.isValid)
        {
            RStatsWorksheet sheet;
            isSummary = data.examine.isDisplaySummary;
            saveOutputDataToWorksheet(data.examine,sheet);
            if (!data.examine.isDisplaySummary)
            {
                sheet("B1").alignment = RStatsTextAlignment::AlignLeft;
                sheet("B1") = "Stratum "+std::to_string(counter) + " - " + data.examine.typeName;
            }
            else
            {
                sheet("B1").alignment = RStatsTextAlignment::AlignLeft;
                sheet("B1") = data.examine.typeName;
            }
            sheet.setRowBackgroundColor(sheet.getNumRows(),Color(50,50,50));
            stratumWorkbook.addWorksheet(sheet);
        }

        if (data.audit.isValid)
        {
            RStatsWorksheet sheet;
            isSummary = data.audit.isDisplaySummary;
            saveOutputDataToWorksheet(data.audit,sheet);
            if (!data.audit.isDisplaySummary)
            {
                sheet("B1").alignment = RStatsTextAlignment::AlignLeft;
                sheet("B1") = "Stratum "+std::to_string(counter) + " - " + data.audit.typeName;
            }
            else
            {
                sheet("B1").alignment = RStatsTextAlignment::AlignLeft;
                sheet("B1") = data.audit.typeName;
            }
            sheet.setRowBackgroundColor(sheet.getNumRows(),Color(50,50,50));
            stratumWorkbook.addWorksheet(sheet);
        }

        if (data.difference.isValid)
        {
            RStatsWorksheet sheet;
            isSummary = data.difference.isDisplaySummary;
            saveOutputDataToWorksheet(data.difference,sheet);
            if (!data.difference.isDisplaySummary)
            {
                sheet("B1").alignment = RStatsTextAlignment::AlignLeft;
                sheet("B1") = "Stratum "+std::to_string(counter) + " - " + data.difference.typeName;
            }
            else
            {
                sheet("B1").alignment = RStatsTextAlignment::AlignLeft;
                sheet("B1") = data.difference.typeName;
            }
            sheet.setRowBackgroundColor(sheet.getNumRows(),Color(50,50,50));
            stratumWorkbook.addWorksheet(sheet);
        }

        RStatsWorksheet stratumSheet = stratumWorkbook.mergeSheets(RStatsWorkbookMergeDirection::MergeBottom);

        std::string title;
        if (isSummary)
        {
            title = "Summary";
        }
        else
        {
            title = "Stratum "+std::to_string(counter);
            ++counter;
        }

        stratumSheet.setWorksheetTitle(title);
        workbookOut.addWorksheet(stratumSheet);

    }
}

void RStatsSVA::saveOutputDataToWorksheet(const RStatsSVAOutputData &data,
                                          RStatsWorksheet &sheet)
{

    sheet.setDefaultTextAlignment(RStatsTextAlignment::AlignRight);
    sheet.setDefaultFont(cbtek::common::utility::Font("arial",11,true));
    sheet("A1")= "Sample Type:";
    sheet("A2")= "Audit Name:";
    sheet("A3")= "Universe Size:";
    sheet("A4")= "Sample Size:";
    sheet("A5")= "Nonzero Count:";
    sheet("A6")= "Creation Date:";
    sheet("A7")= "Creation Time:";
    sheet("A8")= "Created By:";

    sheet("C1")="Mean:";
    sheet("C2")="Skewness:";
    sheet("C3")="Kurtosis:";
    sheet("C4")="Std. Deviation:";
    sheet("C5")="Std. Err. Mean:";
    sheet("C6")="Std. Err. Total:";
    sheet("C7")="Point Estimate:";

    sheet("A11") = "Lower:";
    sheet("A12") = "Upper:";
    sheet("A13")="Precision Amount:";
    sheet("A14")="Precision Percent:";

    sheet.setDefaultTextAlignment(RStatsTextAlignment::AlignMiddle);
    sheet("C9") = "Confidence Levels";
    sheet("B10") = "80%";
    sheet("C10") = "90%";
    sheet("D10") = "95%";
    sheet("B10").bgColor.set(255,127,127);
    sheet("C10").bgColor.set(255,255,127);
    sheet("D10").bgColor.set(127,255,127);
    sheet("B10").fgColor.set(1,1,1);
    sheet("C10").fgColor.set(1,1,1);
    sheet("D10").fgColor.set(1,1,1);
    sheet.setDefaultTextAlignment(RStatsTextAlignment::AlignLeft);

    sheet("B2") = m_auditName;
    sheet("B3") = data.populationSize;
    sheet("B4") = data.sampleSize;
    sheet("B5") = data.nonZeroCount;
    sheet("B6") = DateUtils::toLongDateString(DateUtils::getCurrentDate());
    sheet("B7") = TimeUtils::to12HourTimeString(TimeUtils::getCurrentTime());
    sheet("B8") = SystemUtils::getUserName();

    sheet("D1") = !std::isnan(data.mean) ? StringUtils::toString(data.mean,2) : "0.00";
    sheet("D2") = !std::isnan(data.skewness) ? StringUtils::toString(data.skewness,2): "0.00";
    sheet("D3") = !std::isnan(data.kurtosis) ? StringUtils::toString(data.kurtosis,2): "0.00";
    sheet("D4") = !std::isnan(data.standardDeviation) ? StringUtils::toString(data.standardDeviation,2): "0.00";
    sheet("D5") = !std::isnan(data.standardErrorMean) ? StringUtils::toString(data.standardErrorMean,2): "0.00";
    sheet("D6") = !std::isnan(data.standardErrorTotal) ? StringUtils::toString(data.standardErrorTotal,0) : "0";
    sheet("D7") = !std::isnan(data.pointEstimate) ? StringUtils::toString(data.pointEstimate,0) : "0";

    for (size_t a1 = 1;a1 <=5;++a1)
    {
        if (sheet("D"+std::to_string(a1)).text == "-0.00")
        {
            sheet("D"+std::to_string(a1)) = "0.00";
        }
    }

    sheet.resetDefaults();
    sheet.setDefaultTextAlignment(RStatsTextAlignment::AlignMiddle);
    sheet.setDefaultFont(Font("arial",11));
    sheet.setDefaultFloatingPointDecimals(2);
    sheet.setDefaultFloatingPointDecimals(0);

    sheet("B11") = data.lower80;
    sheet("C11") = data.lower90;
    sheet("D11") = data.lower95;

    sheet("B12") = data.upper80;
    sheet("C12") = data.upper90;
    sheet("D12") = data.upper95;

    sheet("B13") = data.precisionAmount80;
    sheet("C13") = data.precisionAmount90;
    sheet("D13") = data.precisionAmount95;

    if (data.isDisplaySummary)
    {

        std::string percent80 = StringUtils::toString(data.precisionPercent80,2)+"%";
        std::string percent90 = StringUtils::toString(data.precisionPercent90,2)+"%";
        std::string percent95 = StringUtils::toString(data.precisionPercent95,2)+"%";

        sheet("B14") = percent80;
        sheet("C14") = percent90;
        sheet("D14") = percent95;
        sheet("C1")="";
        sheet("C2")="";
        sheet("C3")="";
        sheet("C4")="";
        sheet("D1")="";
        sheet("D2")="";
        sheet("D3")="";
        sheet("D4")="";
        sheet.setDefaultTextAlignment(RStatsTextAlignment::AlignRight);
        sheet.setDefaultFont(cbtek::common::utility::Font("arial",11,true));
        sheet("A15") = "z-Value:";
        sheet.setDefaultFloatingPointDecimals(12);
        sheet.setDefaultTextAlignment(RStatsTextAlignment::AlignMiddle);
        sheet("B15") = StringUtils::toString(data.tValue80,12);
        sheet("C15") = StringUtils::toString(data.tValue90,12);
        sheet("D15") = StringUtils::toString(data.tValue95,12);
    }
    else
    {
        std::string percent80 = StringUtils::toString(data.precisionPercent80*100.,2)+"%";
        std::string percent90 = StringUtils::toString(data.precisionPercent90*100.,2)+"%";
        std::string percent95 = StringUtils::toString(data.precisionPercent95*100.,2)+"%";

        sheet("B14") = percent80;
        sheet("C14") = percent90;
        sheet("D14") = percent95;

        sheet.setDefaultTextAlignment(RStatsTextAlignment::AlignRight);
        sheet.setDefaultFont(cbtek::common::utility::Font("arial",11,true));
        sheet("A15") = "t-Value:";
        sheet.setDefaultFloatingPointDecimals(12);
        sheet.setDefaultTextAlignment(RStatsTextAlignment::AlignMiddle);
        sheet("B15") = data.tValue80;
        sheet("C15") = data.tValue90;
        sheet("D15") = data.tValue95;
    }
}

void RStatsSVA::buildOutputData(RStatsSVAOutputDataList& outputDataList,
                                const RStatsSVAInputData& inputData,
                                RStatsDataFormatType type)
{
    RStatsSVAOutputDataTriplet triplet;

    if (type == RStatsDataFormatType::Examine)
    {
        copyOutputData(triplet.examine,inputData,type,constants::EXAMINE);
    }

    else if (type == RStatsDataFormatType::Audit)
    {        
        copyOutputData(triplet.audit,inputData,type,constants::AUDIT);
    }

    else if (type == RStatsDataFormatType::Difference)
    {
        copyOutputData(triplet.difference,inputData,type,constants::DIFF);
    }

    else
    {
        copyOutputData(triplet.examine,inputData,type,constants::EXAMINE);
        copyOutputData(triplet.audit,inputData,type,constants::AUDIT);
        copyOutputData(triplet.difference,inputData,type,constants::DIFF);
    }

    outputDataList.push_back(triplet);
}


void RStatsSVA::copyOutputData(RStatsSVAOutputData& outputData,
                               const RStatsSVAInputData& inputData,
                               RStatsDataFormatType type,
                               size_t dataFormatIndex)
{

    if (dataFormatIndex == constants::AUDIT)
    {
        outputData.typeName = "Audit Values";
    }
    else if (dataFormatIndex == constants::EXAMINE)
    {
        outputData.typeName = "Examine Values";
    }
    else
    {
        outputData.typeName = "Difference Values";
    }

    outputData.isValid = true;
    outputData.isDisplaySummary = false;
    outputData.auditName = m_auditName;
    outputData.type = type;
    outputData.sampleSize = inputData.sampleSize;
    outputData.populationSize = inputData.universeSize;
    outputData.nonZeroCount = static_cast<RStatsInteger>(m_outputNonZero(dataFormatIndex));
    outputData.mean = m_outputMean(dataFormatIndex);
    outputData.standardDeviation = m_outputStdDev(dataFormatIndex);    
    outputData.skewness = m_outputSkewAmount(dataFormatIndex);
    outputData.standardErrorMean = m_outputStdErr(dataFormatIndex);
    outputData.standardErrorTotal = m_outputStdErr(dataFormatIndex) * inputData.universeSize;
    outputData.pointEstimate = m_outputPNTest(dataFormatIndex);
    outputData.lower80 = m_outputLowerLimit80(dataFormatIndex);
    outputData.lower90 = m_outputLowerLimit90(dataFormatIndex);
    outputData.lower95 = m_outputLowerLimit95(dataFormatIndex);
    outputData.upper80 = m_outputUpperLimit80(dataFormatIndex);
    outputData.upper90 = m_outputUpperLimit90(dataFormatIndex);
    outputData.upper95 = m_outputUpperLimit95(dataFormatIndex);
    outputData.kurtosis = m_outputKurtosisAmount(dataFormatIndex);
    outputData.createDate = DateUtils::getCurrentDate();
    outputData.createTime = TimeUtils::getCurrentTime();
    outputData.precisionAmount80 = m_outputPrecision80(dataFormatIndex) * inputData.universeSize;
    outputData.precisionAmount90 = m_outputPrecision90(dataFormatIndex) * inputData.universeSize;
    outputData.precisionAmount95 = m_outputPrecision95(dataFormatIndex) * inputData.universeSize;

    if (outputData.mean > 0)
    {
        outputData.precisionPercent80 = m_outputPrecision80(dataFormatIndex) / outputData.mean;
        outputData.precisionPercent90 = m_outputPrecision90(dataFormatIndex) / outputData.mean;
        outputData.precisionPercent95 = m_outputPrecision95(dataFormatIndex) / outputData.mean;
    }

    outputData.tValue80 = m_outputTValue80;
    outputData.tValue90 = m_outputTValue90;
    outputData.tValue95 = m_outputTValue95;

}



RStatsSVA::RStatsSVA()
{
    m_totalSampleSize = 0;
    onReset();
}

RStatsSVA::~RStatsSVA()
{

}

RStatsSVAInputDataList RStatsSVA::buildInputDataList(const RStatsWorksheet &dataSheet,
                                                     const RStatsWorksheet &sizeSheet,
                                                     const RStatsDataFormatTypeIndex &dataSheetIndex,
                                                     size_t dataSheetRowStart,
                                                     size_t sizeSheetSampleSizeColumn,
                                                     size_t sizeSheetUniverseSizeColumn,
                                                     size_t sizeSheetRowStart)
{

    RStatsSVAInputDataList dataList;
    size_t dataRowOffset = dataSheetRowStart;
    for (size_t r = sizeSheetRowStart; r < sizeSheet.getNumRows(); ++r)
    {
        RStatsSVAInputData stratum;

        //Read size info for stratum
        std::string universeSize = sizeSheet(r,sizeSheetUniverseSizeColumn).text;
        std::string sampleSize = sizeSheet(r,sizeSheetSampleSizeColumn).text;

        stratum.universeSize = StringUtils::toInt(universeSize);
        stratum.sampleSize = StringUtils::toInt(sampleSize);
        stratum.offset = static_cast<RStatsInteger>(dataRowOffset);
        stratum.typeIndex = dataSheetIndex;
        bool isMultiDataFormat = (stratum.typeIndex.type == RStatsDataFormatType::AuditAndDifference ||
                                  stratum.typeIndex.type == RStatsDataFormatType::ExamineAndAudit ||
                                  stratum.typeIndex.type == RStatsDataFormatType::ExamineAndDifference);

        std::pair<std::string,std::string> typePair = RStatsUtils::getDataFormatTypeStr(stratum.typeIndex.type);
        std::string primaryTypeStr = typePair.first;
        std::string secondaryTypeStr = typePair.second;

        stratum.samples.initialize(static_cast<size_t>(stratum.sampleSize),(isMultiDataFormat)?2:1);
        size_t index = 0;
        //For each stratum lets grab the data samples
        for (RStatsInteger a1 = 0; a1 < stratum.sampleSize;++a1)
        {
            std::string value1 = dataSheet(static_cast<size_t>(a1+stratum.offset),
                                           stratum.typeIndex.primaryDatasetColumnIndex).text;
            StringUtils::removeInPlace(value1, "$");
            StringUtils::removeInPlace(value1, "(");
            StringUtils::removeInPlace(value1, ")");
            StringUtils::removeInPlace(value1, ",");
            if (!StringUtils::isNumeric(value1))
            {
                THROW_GENERIC_EXCEPTION("The "+primaryTypeStr+" value \""+value1+"\" in row \""+std::to_string(a1+stratum.offset+1)+"\" is not a valid number!");
            }

            stratum.samples(index,0) = StringUtils::toFloat64(value1);
            std::string value2;
            if (isMultiDataFormat)
            {
                value2 = dataSheet(static_cast<size_t>(a1+stratum.offset),
                                   stratum.typeIndex.secondaryDatasetColumnIndex).text;
                StringUtils::removeInPlace(value2, "$");
                StringUtils::removeInPlace(value2, "(");
                StringUtils::removeInPlace(value2, ")");
                StringUtils::removeInPlace(value2, ",");
                if (!StringUtils::isNumeric(value2))
                {
                    THROW_GENERIC_EXCEPTION("The "+secondaryTypeStr+" value \""+value2+"\" in row \""+std::to_string(a1+stratum.offset+1)+"\" is not a valid number!");
                }
                stratum.samples(index,1) = StringUtils::toFloat64(value2);
            }
            ++index;
            ++dataRowOffset;
        }
        dataList.push_back(stratum);
    }
    return dataList;
}

void RStatsSVA::onReset()
{    
    m_outputTValue80 = 0.;
    m_outputTValue90 = 0.;
    m_outputTValue95 = 0.;
    m_formulaVarA = 0.;
    m_formulaVarB = 0.;
    m_formulaVarT = 0.;
    m_formulaVarPI = 0.;
    m_formulaVarX = 0.;
    m_formulaVarC0 = 0.;
    m_frontValue = 0.;
    m_eps = 0.;
    m_outputDOF = 0.;
    m_outputSEFIN = 0.;
    m_formulaVarTLast = 0.;
    m_lowValue = 0.;
    m_highValue = 0.;
    m_newProbability = 0.;
    m_lowProbability = 0.;
    m_highProbability = 0.;
    m_difference = 0.;
    m_cumaltiveProbability = 0.;
    m_currentProbability = 0.;
    m_temporary80 = 0.;
    m_temporary90 = 0.;
    m_temporary95 = 0.;
    m_lastLogValue = 0.;
    m_logValue1 = 0.;
    m_logValue2 = 0.;
    m_logValue3 = 0.;
    m_logValue4 = 0.;
    m_totalAmount = 0.;
    m_examineSum = 0.;
    m_auditSum = 0.;
    m_differenceSum = 0.;
    m_dataFormatTypeAvailableFlag.initialize(3);
    m_outputNonZero.initialize(3);
    m_outputSkewAmount.initialize(3);
    m_outputSkewVAmount.initialize(3);
    m_outputKurtosisAmount.initialize(3);
    m_outputKurtosisVAmount.initialize(3);
    m_valuesC.initialize(1000);
    m_outputSum.initialize(3);
    m_outputSumSqrt.initialize(3);
    m_outputSumCbrt.initialize(3);
    m_outputSumQdrt.initialize(3);
    m_examValues.initialize(3);
    m_auditValues.initialize(3);
    m_differenceValues.initialize(3);
    m_outputMean.initialize(3);
    m_outputPrecision80.initialize(3);
    m_outputPrecision90.initialize(3);
    m_outputPrecision95.initialize(3);
    m_outputVPrecision80.initialize(3);
    m_outputVPrecision90.initialize(3);
    m_outputVPrecision95.initialize(3);
    m_outputPNTest.initialize(3);
    m_outputPNTestTemp.initialize(3);
    m_outputVMean.initialize(3);
    m_outputVProjectNumber.initialize(3);
    m_outputStdDev.initialize(3);
    m_outputStdErr.initialize(3);
    m_outputVStdDev.initialize(3);
    m_outputTermSE.initialize(3);
    m_outputStdDevTemp.initialize(3);
    m_outputStdErrTemp.initialize(3);
    m_outputUpperLimit80.initialize(3);
    m_outputUpperLimit90.initialize(3);
    m_outputUpperLimit95.initialize(3);
    m_outputLowerLimit80.initialize(3);
    m_outputLowerLimit90.initialize(3);
    m_outputLowerLimit95.initialize(3);
    m_outputVUpperLimit80.initialize(3);
    m_outputVUpperLimit90.initialize(3);
    m_outputVUpperLimit95.initialize(3);
    m_outputVLowerLimit80.initialize(3);
    m_outputVLowerLimit90.initialize(3);
    m_outputVLowerLimit95.initialize(3);
    m_outputUpperLimitTemp80.initialize(3);
    m_outputUpperLimitTemp90.initialize(3);
    m_outputUpperLimitTemp95.initialize(3);
    m_outputLowerLimitTemp80.initialize(3);
    m_outputLowerLimitTemp90.initialize(3);
    m_outputLowerLimitTemp95.initialize(3);
    m_outputPrecisionTemp80.initialize(3);
    m_outputPrecisionTemp90.initialize(3);
    m_outputPrecisionTemp95.initialize(3);
    m_outputVStdErr.initialize(3);
    m_outputNonZeroTemp.initialize(3);

    m_currentIteration = 0;
    m_currentNonZero = 0;
    m_examineZeroCount = 0;
    m_auditZeroCount = 0;
    m_differenceZeroCount = 0;
    m_outputNonZeroSize = 0;
    m_numTerms = 0;
    m_maxIterations = 0;
    m_numStrata = 0;
    m_conditionCount = 0;    
}

void RStatsSVA::onUpdateSums(const RStatsFloatList &auditValues,
                             const RStatsFloatList &examValues,
                             const RStatsFloatList &differenceValues
                            )
{

    m_outputSum(0) += RStatsUtils::getSum(examValues);
    m_outputSumSqrt(0) += RStatsUtils::getSumRaisedTo<RStatsFloat>(examValues,2);
    m_outputSumCbrt(0) += RStatsUtils::getSumRaisedTo<RStatsFloat>(examValues,3);
    m_outputSumQdrt(0) += RStatsUtils::getSumRaisedTo<RStatsFloat>(examValues,4);
    m_outputNonZero(0) += RStatsUtils::getNumItemsThatMatchCondition(RStatsConditionalOperatorType::NotEqual,
                                                                     examValues,
                                                                     0.);

    m_summaryNonZeroCount(0) += m_outputNonZero(0);

    m_outputSum(1) += RStatsUtils::getSum(auditValues);
    m_outputSumSqrt(1) += RStatsUtils::getSumRaisedTo<RStatsFloat>(auditValues,2);
    m_outputSumCbrt(1) += RStatsUtils::getSumRaisedTo<RStatsFloat>(auditValues,3);
    m_outputSumQdrt(1) += RStatsUtils::getSumRaisedTo<RStatsFloat>(auditValues,4);
    m_outputNonZero(1) += RStatsUtils::getNumItemsThatMatchCondition(RStatsConditionalOperatorType::NotEqual,
                                                                     auditValues,
                                                                     0.);
    m_summaryNonZeroCount(1) += m_outputNonZero(1);

    m_outputSum(2) += RStatsUtils::getSum(differenceValues);
    m_outputSumSqrt(2) += RStatsUtils::getSumRaisedTo<RStatsFloat>(differenceValues,2);
    m_outputSumCbrt(2) += RStatsUtils::getSumRaisedTo<RStatsFloat>(differenceValues,3);
    m_outputSumQdrt(2) += RStatsUtils::getSumRaisedTo<RStatsFloat>(differenceValues,4);
    m_outputNonZero(2) += RStatsUtils::getNumItemsThatMatchCondition(RStatsConditionalOperatorType::NotEqual,
                                                                     differenceValues,
                                                                     0.);
    m_summaryNonZeroCount(2) += m_outputNonZero(2);
}


void RStatsSVA::initializeDataTypeFormat(RStatsDataFormatType dataTypeFormat,
                                         const RStatsSVAInputData& inputData)
{

    if (dataTypeFormat == RStatsDataFormatType::Examine)
    {
        m_examineZeroCount = RStatsUtils::getNumItemsThatMatchCondition(RStatsConditionalOperatorType::NotEqual,
                                                                        inputData.samples,
                                                                        0.0,
                                                                        0);
        m_dataFormatTypeAvailableFlag(0) = true;
        m_examineSum = RStatsUtils::getSum(inputData.samples);
        m_outputSum(0) += m_examineSum;        
        m_outputSumSqrt(0) += RStatsUtils::getSumRaisedTo<RStatsFloat>(inputData.samples,2);
        m_outputSumCbrt(0) += RStatsUtils::getSumRaisedTo<RStatsFloat>(inputData.samples,3);
        m_outputSumQdrt(0) += RStatsUtils::getSumRaisedTo<RStatsFloat>(inputData.samples,4);
        m_outputNonZero(0) += m_examineZeroCount;
        m_summaryNonZeroCount(0) += m_examineZeroCount;
    }
    else if (dataTypeFormat == RStatsDataFormatType::Audit)
    {
        m_auditZeroCount = RStatsUtils::getNumItemsThatMatchCondition(RStatsConditionalOperatorType::NotEqual,
                                                                      inputData.samples,
                                                                      0.0,
                                                                      0);
        m_dataFormatTypeAvailableFlag(1) = true;
        m_auditSum = RStatsUtils::getSum(inputData.samples);
        m_outputSum(1) += m_auditSum;
        m_outputSumSqrt(1) += RStatsUtils::getSumRaisedTo<RStatsFloat>(inputData.samples,2);
        m_outputSumCbrt(1) += RStatsUtils::getSumRaisedTo<RStatsFloat>(inputData.samples,3);
        m_outputSumQdrt(1) += RStatsUtils::getSumRaisedTo<RStatsFloat>(inputData.samples,4);
        m_outputNonZero(1) += m_auditZeroCount;
        m_summaryNonZeroCount(1) += m_auditZeroCount;

    }
    else if (dataTypeFormat == RStatsDataFormatType::Difference)
    {
        m_differenceZeroCount = RStatsUtils::getNumItemsThatMatchCondition(RStatsConditionalOperatorType::NotEqual,
                                                                           inputData.samples,
                                                                           0.0,
                                                                           0);
        m_dataFormatTypeAvailableFlag(2) = true;
        m_differenceSum = RStatsUtils::getSum(inputData.samples);
        m_outputSum(2) += m_differenceSum;
        m_outputSumSqrt(2) += RStatsUtils::getSumRaisedTo<RStatsFloat>(inputData.samples,2);
        m_outputSumCbrt(2) += RStatsUtils::getSumRaisedTo<RStatsFloat>(inputData.samples,3);
        m_outputSumQdrt(2) += RStatsUtils::getSumRaisedTo<RStatsFloat>(inputData.samples,4);
        m_outputNonZero(2) += m_differenceZeroCount;
        m_summaryNonZeroCount(2) += m_differenceZeroCount;
    }    
    else if (dataTypeFormat == RStatsDataFormatType::ExamineAndAudit)
    {
        if (inputData.samples.getNumDimensions() > 1)
        {
            m_examValues.addValues(inputData.samples,0);
            m_auditValues.addValues(inputData.samples,1);
            m_differenceValues = RStatsUtils::getNumbersSubtracted(m_examValues,m_auditValues);
            m_examineSum = RStatsUtils::getSum(m_examValues);
            m_differenceSum = RStatsUtils::getSum(m_differenceValues);
            m_auditSum = RStatsUtils::getSum(m_auditValues);
            m_dataFormatTypeAvailableFlag(0) = true;
            m_dataFormatTypeAvailableFlag(1) = true;
            m_dataFormatTypeAvailableFlag(2) = true;

            onUpdateSums(m_auditValues,
                     m_examValues,
                     m_differenceValues);
        }
    }

    else if (dataTypeFormat == RStatsDataFormatType::ExamineAndDifference)
    {
        if (inputData.samples.getNumDimensions() > 1)
        {
            m_examValues.addValues(inputData.samples,0);
            m_differenceValues.addValues(inputData.samples,1);
            m_auditValues = RStatsUtils::getNumbersSubtracted(m_examValues,m_differenceValues);
            m_examineSum = RStatsUtils::getSum(m_examValues);
            m_differenceSum = RStatsUtils::getSum(m_differenceValues);
            m_auditSum = RStatsUtils::getSum(m_auditValues);

            m_dataFormatTypeAvailableFlag(0) = true;
            m_dataFormatTypeAvailableFlag(1) = true;
            m_dataFormatTypeAvailableFlag(2) = true;

            onUpdateSums(m_auditValues,
                     m_examValues,
                     m_differenceValues);

        }
    }

    else if (dataTypeFormat == RStatsDataFormatType::AuditAndDifference)
    {
        if (inputData.samples.getNumDimensions() > 1)
        {
            m_auditValues.addValues(inputData.samples,0);
            m_differenceValues.addValues(inputData.samples,1);
            m_examValues = RStatsUtils::getNumbersAdded(m_auditValues,m_differenceValues);
            m_examineSum = RStatsUtils::getSum(m_examValues);
            m_differenceSum = RStatsUtils::getSum(m_differenceValues);
            m_auditSum = RStatsUtils::getSum(m_auditValues);

            m_dataFormatTypeAvailableFlag(0) = true;
            m_dataFormatTypeAvailableFlag(1) = true;
            m_dataFormatTypeAvailableFlag(2) = true;

            onUpdateSums(m_auditValues,
                     m_examValues,
                     m_differenceValues);
        }
    }
}
//'---------CALCULATE MEAN--------
void RStatsSVA::calculateMean(const RStatsSVAInputData& inputData)
{
    for (size_t a1 = 0; a1 < 3; ++a1)
    {
        if (inputData.sampleSize > 0 &&
            m_currentNonZero > 0 &&
            m_dataFormatTypeAvailableFlag(a1))
        {
            m_outputMean(a1) = m_outputSum(a1) / static_cast<RStatsFloat>(inputData.sampleSize);
            m_summaryTotalMean(a1) += m_outputMean(a1);
        }
    }
}

//'----------CALCULATE STANDARD DEVIATION----------
void RStatsSVA::calculateStandardDeviation(const RStatsSVAInputData &inputData)
{
    for (size_t a1 = 0; a1 < 3; ++a1)
    {
        if (!RStatsUtils::isEqual(m_outputSum(a1), 0.0) &&
            inputData.sampleSize > 1 &&
            m_dataFormatTypeAvailableFlag(a1))
        {
            RStatsFloat totalAmount = m_outputSum(a1);
            RStatsFloat sampleSize = inputData.sampleSize;
            RStatsFloat sqRt = m_outputSumSqrt(a1);
            RStatsFloat universeSize = inputData.universeSize;
            RStatsFloat temp1 = std::pow(totalAmount,2) / sampleSize;
            if (temp1 < sqRt)
            {
                m_outputStdDev(a1) = (std::sqrt((sqRt - temp1) / m_outputDOF));
            }
            else
            {
                m_outputStdDev(a1) = 0.;
            }
            m_outputStdDevTemp(a1) += (m_outputStdDevTemp(a1) + std::pow(m_outputStdDev(a1),2) * std::pow(universeSize,2));
            m_summaryStandardDeviation(a1) += m_outputStdDevTemp(a1);
        }
        m_outputVStdDev(a1) = m_outputStdDev(a1);
    }
}

//'----------CALCULATE STANDARD ERROR----------
void RStatsSVA::calculateStandardError(const RStatsSVAInputData& inputData)
{
    for (size_t a1 = 0; a1 < 3; ++a1)
    {
        if (!RStatsUtils::isEqual(m_outputStdDev(a1), 0.0) &&
            inputData.sampleSize > 1 &&
            m_dataFormatTypeAvailableFlag(a1))
        {
            RStatsFloat stdDev = m_outputStdDev(a1);
            RStatsFloat sqrSampSize = std::sqrt(inputData.sampleSize);
            m_outputStdErr(a1) = (stdDev / sqrSampSize) * m_outputSEFIN;
            RStatsFloat tempValue = inputData.universeSize;
            tempValue *= (inputData.universeSize - inputData.sampleSize);
            tempValue *= (std::pow(m_outputStdDev(a1),2));
            tempValue /= static_cast<RStatsFloat>(inputData.sampleSize);
            m_outputTermSE(a1) = tempValue;
            m_outputStdErrTemp(a1) += m_outputTermSE(a1);
            m_summaryStandardErrorMean(a1) += m_outputTermSE(a1);
        }
    }
}

//'---------CALCULATE CORRECTION FACTORS-------
void RStatsSVA::calculateCorrectionFactors(const RStatsSVAInputData& inputData)
{
    if (inputData.universeSize > 1)
    {
        RStatsFloat value = static_cast<RStatsFloat>(inputData.universeSize - inputData.sampleSize) / (static_cast<RStatsFloat>(inputData.universeSize));
        m_outputSEFIN = std::sqrt(value);
    }
}

//'---------CALCULATE DEGREES OF FREEDOM-------
void RStatsSVA::calculateDegreesOfFreedom(const RStatsSVAInputData& inputData)
{
    m_outputDOF = inputData.sampleSize - 1;
}

//'----------CALCULATE POINT ESTIMATES------
void RStatsSVA::calculatePointEstimates(const RStatsSVAInputData& inputData)
{
    for (size_t a1 = 0; a1 < 3; ++a1)
    {
        m_outputPNTest(a1) = m_outputMean(a1) * static_cast<RStatsFloat>(inputData.universeSize);
        m_outputPNTestTemp(a1) = m_outputPNTestTemp(a1) + m_outputPNTest(a1);
        m_summaryPointEstimate(a1) += m_outputPNTest(a1);
        m_outputVProjectNumber(a1) = m_outputPNTest(a1);
    }
}

//'----------CALCULATE LOWER AND UPPER LIMITS-----------
void RStatsSVA::calculateUpperAndLowerLimits(const RStatsSVAInputData& inputData)
{
    for (size_t a1 = 0; a1 < 3; ++a1)
    {
        if (m_outputNonZero(a1) > 0)
        {
            RStatsFloat temp0 = m_outputPrecision80(a1) * static_cast<RStatsFloat>(inputData.universeSize);
            RStatsFloat temp1 = m_outputPrecision90(a1) * static_cast<RStatsFloat>(inputData.universeSize);
            RStatsFloat temp2 = m_outputPrecision95(a1) * static_cast<RStatsFloat>(inputData.universeSize);

            m_outputLowerLimit80(a1) = m_outputPNTest(a1) - temp0;
            m_outputLowerLimit90(a1) = m_outputPNTest(a1) - temp1;
            m_outputLowerLimit95(a1) = m_outputPNTest(a1) - temp2;

            m_outputUpperLimit80(a1) = m_outputPNTest(a1) + temp0;
            m_outputUpperLimit90(a1) = m_outputPNTest(a1) + temp1;
            m_outputUpperLimit95(a1) = m_outputPNTest(a1) + temp2;

            m_outputVUpperLimit80(a1) = m_outputUpperLimit80(a1);
            m_outputVLowerLimit80(a1) = m_outputLowerLimit80(a1);

            m_outputVLowerLimit90(a1) = m_outputLowerLimit90(a1);
            m_outputVUpperLimit90(a1) = m_outputUpperLimit90(a1);

            m_outputVLowerLimit95(a1) = m_outputLowerLimit95(a1);
            m_outputVUpperLimit95(a1) = m_outputUpperLimit95(a1);
        }
    }
}

//'----------CALCULATE SKEWNESS-----------
void RStatsSVA::calculateSkewness(const RStatsSVAInputData& inputData)
{
    for (size_t a1 = 0; a1 < 3; ++a1)
    {
        if (inputData.sampleSize > 0 &&
            m_currentNonZero > 0 &&
            m_dataFormatTypeAvailableFlag(a1))
        {
            RStatsFloat temp1 = m_outputSumCbrt(a1) / inputData.sampleSize;
            temp1 -= (3 * (m_outputSumSqrt(a1) / inputData.sampleSize) * m_outputMean(a1));
            temp1 += (2 * std::pow(m_outputMean(a1),3));
            RStatsFloat temp2;
            if (m_outputSumSqrt(a1) / inputData.sampleSize > std::pow(m_outputMean(a1),2))
            {
                temp2 = std::sqrt(m_outputSumSqrt(a1) / inputData.sampleSize - (std::pow(m_outputMean(a1),2)));
            }
            else
            {
                temp2 = 0;
            }
            if (temp2 > 1 || RStatsUtils::isEqual(temp2, 1.))
            {
                m_outputSkewAmount(a1) = temp1 / std::pow(temp2,3);
            }
        }
        m_outputSkewVAmount(a1) = m_outputSkewAmount(a1);
    }
}

//'----------CALCULATE KURTOSIS-------------
void RStatsSVA::calculateKurtosis(const RStatsSVAInputData& inputData)
{
    for (size_t a1 = 0; a1 < 3; ++a1)
    {
        if (inputData.sampleSize > 0 &&
            m_currentNonZero > 0 &&
            m_dataFormatTypeAvailableFlag(a1))
        {
            RStatsFloat cubeRt = m_outputSumCbrt(a1);
            RStatsFloat quadRt = m_outputSumQdrt(a1);
            RStatsFloat sqRt = m_outputSumSqrt(a1);
            RStatsFloat sampSize = static_cast<RStatsFloat>(inputData.sampleSize);
            RStatsFloat mean = m_outputMean(a1);

            RStatsFloat temp1 = quadRt / sampSize;
            temp1 -= (4 * (cubeRt / sampSize)) * mean;
            temp1 += (6 * (sqRt / sampSize) * std::pow(mean,2));
            temp1 -= (3 * std::pow(mean,4));
            RStatsFloat temp2 = 0.;
            if (sqRt / sampSize > std::pow(mean,2))
            {
                temp2 = std::sqrt(sqRt / sampSize - std::pow(mean,2));
            }
            else
            {
                temp2 = 0;
            }
            if (temp2 > 1 || RStatsUtils::isEqual(temp2,1.))
            {
                m_outputKurtosisAmount(a1) = temp1 / std::pow(temp2,4);
            }
        }
        m_outputKurtosisVAmount(a1) = m_outputKurtosisAmount(a1);
    }
}

//'---------CALCULATE SAMPLING ERROR---------
void RStatsSVA::calculateSamplingError(const RStatsSVAInputData& inputData)
{
    m_temporary80 = 0.;
    m_temporary90 = 0.;
    m_temporary95 = 0.;
    if (m_outputDOF > 3)
    {
        processSamplingError(inputData);
    }
    else if (m_outputDOF == 1)
    {
        m_temporary80 = 3.077683537175;
        m_temporary90 = 6.313751514675;
        m_temporary95 = 12.706204736175;
    }
    else if (m_outputDOF == 2)
    {
        m_temporary80 = 1.885618083164;
        m_temporary90 = 2.919985580354;
        m_temporary95 = 4.30265272975;
    }
    else if (m_outputDOF == 3)
    {
        m_temporary80 = 1.637744353696;
        m_temporary90 = 2.353363434802;
        m_temporary95 = 3.182446305284;
    }
    calculateIntervals(inputData);
    //processSamplingError(inputData);
}

void RStatsSVA::processSamplingError(const RStatsSVAInputData& inputData)
{
    m_numTerms = 100;
    m_maxIterations = 1000;
    m_eps = 0.00000000000001;
    m_formulaVarA = 0.5;
    m_formulaVarB = static_cast<RStatsFloat>(m_outputDOF) / 2.;
    m_formulaVarPI = 4 * std::atan(1);
    m_conditionCount = 0;
    processConditionLoop(inputData);
}

void RStatsSVA::processConditionLoop(const RStatsSVAInputData& inputData)
{
    m_conditionCount++;
    m_lowValue = 0;
    m_highValue = 4;
    RStatsFloat condition = 0.;
    if (m_conditionCount == 1)
    {
        condition = 80.;
    }
    else if (m_conditionCount == 2)
    {
        condition = 90.;
    }
    else if (m_conditionCount == 3)
    {
        condition = 95.;
    }
    m_cumaltiveProbability = condition / 200 + 0.5;

    m_formulaVarT = m_lowValue;
    processFindCumProb(inputData);
    m_lowProbability = m_currentProbability;

    m_formulaVarT = m_highValue;
    processFindCumProb(inputData);
    m_highProbability = m_currentProbability;

    m_currentIteration = 0;
    processStartLoop(inputData);
}

void RStatsSVA::processStartLoop(const RStatsSVAInputData& inputData)
{
    m_currentIteration++;
    m_formulaVarTLast = m_formulaVarT;

    m_formulaVarT = ((m_lowValue + m_highValue) / 2.);
    //std::cerr << "((" << m_lowValue << " + " << m_highValue << ") / 2 = " << m_formulaVarT << std::endl;
    processFindCumProb(inputData);
    m_newProbability = m_currentProbability;;
    if (m_currentProbability < m_cumaltiveProbability)
    {
        m_lowValue = m_formulaVarT;
    }
    else
    {
        m_highValue = m_formulaVarT;
    }

    m_difference = fabs(m_formulaVarT - m_formulaVarTLast) - m_eps;
    if (m_difference < 0 || RStatsUtils::isEqual(m_formulaVarT,0.))
    {
        if (m_conditionCount == 1)
        {
            m_temporary80 = m_formulaVarT;
        }
        else if (m_conditionCount == 2)
        {
            m_temporary90 = m_formulaVarT;
        }
        else if (m_conditionCount == 3)
        {
            m_temporary95 = m_formulaVarT;
        }
    }
    else
    {
        if (m_currentIteration < m_maxIterations)
        {
            processStartLoop(inputData);
        }
        else
        {
            THROW_GENERIC_EXCEPTION("Program was unable to determine a t-value");
        }
    }
    if (m_conditionCount < 3)
    {
        processConditionLoop(inputData);
    }
    else
    {
        calculateIntervals(inputData);
    }
}

void RStatsSVA::processFindCumProb(const RStatsSVAInputData& inputData)
{
    m_formulaVarX = std::pow(m_formulaVarT,2) / (std::pow(m_formulaVarT,2) + m_outputDOF);
    RStatsInteger numTermsTemp = 0;
    if (m_outputDOF == 2)
    {
        m_formulaVarC0 = 1;
        processFindTerms(inputData);
    }
    else if (m_outputDOF == 3)
    {
        m_formulaVarC0 = 4 / m_formulaVarPI;
        processFindTerms(inputData);
    }
    if ((m_outputDOF - 2 * (int)(m_outputDOF / 2) == 0))
    {
        m_formulaVarC0 = 1;
        numTermsTemp = m_outputDOF / 2 - 1;
        for (RStatsInteger a1 = 0; a1 < numTermsTemp; ++a1)
        {
            RStatsFloat temp = 2 * (a1+1) + 1;
            m_formulaVarC0 = (m_formulaVarC0 * temp) / (temp - 1);
        }
        processFindTerms(inputData);
    }
    else
    {
        m_formulaVarC0 = 4 / m_formulaVarPI;
        numTermsTemp = ((m_outputDOF - 1) / 2) - 1;
        for (RStatsInteger a1 = 0; a1 < numTermsTemp; ++a1)
        {
            RStatsFloat temp = 2 * (a1+1) + 2;
            m_formulaVarC0 = (m_formulaVarC0 * temp) / (temp - 1);
        }
    }
    processFindTerms(inputData);
}

void RStatsSVA::processFindTerms(const RStatsSVAInputData& inputData)
{
    m_frontValue = std::pow((1 - m_formulaVarX), m_formulaVarB) * std::pow(m_formulaVarX,m_formulaVarA);
    RStatsFloat tempValue = m_formulaVarC0;
    m_valuesC(0) = m_formulaVarC0;
    RStatsFloat logOld = std::log(m_valuesC(0));
    if (RStatsUtils::isEqual(m_formulaVarX,0))
    {
        tempValue = 0;
        processFindProbVal(tempValue);
        return;
    }
    for (RStatsInteger a1 = 0; a1 < m_numTerms;++a1)
    {
        m_logValue1 = std::log((a1 + m_formulaVarA + m_formulaVarB) / (a1+1+m_formulaVarA));
        m_logValue2 = logOld;
        m_logValue3 = std::log(m_formulaVarX);
        m_logValue4 = m_logValue1 + m_logValue2 + (a1 + 1) * std::log(m_formulaVarX);
        logOld = m_logValue1 + m_logValue2;
        tempValue = tempValue + std::exp(m_logValue4);
    }
    processFindProbVal(tempValue);
}

void RStatsSVA::processFindProbVal(RStatsFloat tempValue)
{
    m_currentProbability = .5 * (m_frontValue * tempValue + 1);
}



void RStatsSVA::calculateIntervals(const RStatsSVAInputData & inputData)
{
    m_outputTValue80 = m_temporary80;
    m_outputTValue90 = m_temporary90;
    m_outputTValue95 = m_temporary95;

    for (size_t a1 = 0; a1 < 3; ++a1)
    {
        if (m_outputNonZero(a1) > 0)
        {
            m_outputPrecision80(a1) = m_temporary80 * m_outputStdErr(a1);
            m_outputPrecision90(a1) = m_temporary90 * m_outputStdErr(a1);
            m_outputPrecision95(a1) = m_temporary95 * m_outputStdErr(a1);
        }

        RStatsFloat universe = static_cast<RStatsFloat>(inputData.universeSize);
        m_outputVPrecision80(a1) = m_outputPrecision80(a1) * universe;
        m_outputVPrecision90(a1) = m_outputPrecision90(a1) * universe;
        m_outputVPrecision95(a1) = m_outputPrecision95(a1) * universe;
    }

    calculateUpperAndLowerLimits(inputData);
    calculateSkewness(inputData);
    calculateKurtosis(inputData);
    //calculateOverallPrecision(inputData);
}

void RStatsSVA::calculateOverallPrecision()
{
    for (size_t a1 = 0; a1 < 3; ++a1)
    {
        if (m_outputNonZero(a1) > 0 &&
            m_dataFormatTypeAvailableFlag(a1))
        {

            m_summaryStandardErrorMean(a1) = std::sqrt(m_summaryStandardErrorMean(a1));
            m_summaryPrecisionAmount80(a1) = constants::ZVAL80 * m_summaryStandardErrorMean(a1);
            m_summaryLowerLimit80(a1) = m_summaryPointEstimate(a1) - m_summaryPrecisionAmount80(a1);
            m_summaryUpperLimit80(a1) = m_summaryPointEstimate(a1) + m_summaryPrecisionAmount80(a1);

            m_summaryPrecisionAmount90(a1) = constants::ZVAL90 * m_summaryStandardErrorMean(a1);
            m_summaryLowerLimit90(a1) = m_summaryPointEstimate(a1) - m_summaryPrecisionAmount90(a1);
            m_summaryUpperLimit90(a1) = m_summaryPointEstimate(a1) + m_summaryPrecisionAmount90(a1);

            m_summaryPrecisionAmount95(a1) = constants::ZVAL95 * m_summaryStandardErrorMean(a1);
            m_summaryLowerLimit95(a1) = m_summaryPointEstimate(a1) - m_summaryPrecisionAmount95(a1);
            m_summaryUpperLimit95(a1) = m_summaryPointEstimate(a1) + m_summaryPrecisionAmount95(a1);

        }
    }
}
}}}}//end namespace

