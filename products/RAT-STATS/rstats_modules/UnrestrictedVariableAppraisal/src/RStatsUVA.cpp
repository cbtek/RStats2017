/*
    RStatsUVA.cpp
    

*/
//----------------------------------------
//RStatsUVA.cpp generated by CBTek Solutions on 02-07-2017 at 01:15:14 AM
//----------------------------------------

#include "RStatsUVA.h"

using namespace oig::ratstats::utils;

namespace oig {
namespace ratstats {
namespace modules {
namespace uva {

RStatsUVA RStatsUVA::m_instance = RStatsUVA();


RStatsUVA & RStatsUVA::inst()
{
    return m_instance;
}

void RStatsUVA::execute(const utils::RStatsFloatList &values,
                        size_t sampleSize,
                        size_t universeSize,
                        RStatsDataFormatType type)
{
    this->reset();
    m_sampleSize = sampleSize;
    m_universeSize = universeSize;
    RStatsFloatList auditValues,examineValues,differenceValues;
    if (type == RStatsDataFormatType::Examine)
    {
        examineValues = values;
    }
    else if (type == RStatsDataFormatType::Audit)
    {
        auditValues = values;
    }
    else if (type == RStatsDataFormatType::Difference)
    {
        differenceValues = values;
    }
    else if (type == RStatsDataFormatType::ExamineAndAudit)
    {
        examineValues = values.getValues(0);
        auditValues = values.getValues(1);
        differenceValues = RStatsUtils::getNumbersSubtracted(examineValues,auditValues);
    }
    else if (type == RStatsDataFormatType::ExamineAndDifference)
    {
        examineValues = values.getValues(0);
        differenceValues = values.getValues(1);
        auditValues = RStatsUtils::getNumbersSubtracted(examineValues,differenceValues);
    }
    else if (type == RStatsDataFormatType::AuditAndDifference)
    {
        auditValues = values.getValues(0);
        differenceValues = values.getValues(1);
        examineValues = RStatsUtils::getNumbersAdded(auditValues,differenceValues);
    }

    for (size_t a1 = 0; a1 < sampleSize; ++a1)
    {
        double value = 0.;
        if (type == RStatsDataFormatType::Examine)
        {
            value = examineValues(a1);
            m_totalAmount(0) += value;
            m_totalPowerOfTwoAmount(0) += std::pow(value,2);
            m_totalPowerOfThreeAmount(0) += std::pow(value,3);
            m_totalPowerOfFourAmount(0) += std::pow(value,4);
            if (!RStatsUtils::isEqual<RStatsFloat>(value,0.))
            {
                m_totalNonZeroCount(0)++;
            }
        }
        else if (type == RStatsDataFormatType::Audit)
        {
            value = auditValues(a1);
            m_totalAmount(1) += value;
            m_totalPowerOfTwoAmount(1) += std::pow(value,2);
            m_totalPowerOfThreeAmount(1) += std::pow(value,3);
            m_totalPowerOfFourAmount(1) += std::pow(value,4);
            if (!RStatsUtils::isEqual<RStatsFloat>(value,1.))
            {
                m_totalNonZeroCount(1)++;
            }
        }
        else if (type == RStatsDataFormatType::Difference)
        {
            value = differenceValues(a1);
            m_totalAmount(2) += value;
            m_totalPowerOfTwoAmount(2) += std::pow(value,2);
            m_totalPowerOfThreeAmount(2) += std::pow(value,3);
            m_totalPowerOfFourAmount(2) += std::pow(value,4);
            if (!RStatsUtils::isEqual<RStatsFloat>(value,2.))
            {
                m_totalNonZeroCount(2)++;
            }
        }
        else
        {
            value = examineValues(a1);
            m_totalAmount(0) += value;
            m_totalPowerOfTwoAmount(0) += std::pow(value,2);
            m_totalPowerOfThreeAmount(0) += std::pow(value,3);
            m_totalPowerOfFourAmount(0) += std::pow(value,4);
            if (!RStatsUtils::isEqual<RStatsFloat>(value,0.))
            {
                m_totalNonZeroCount(0)++;
            }

            value = auditValues(a1);
            m_totalAmount(1) += value;
            m_totalPowerOfTwoAmount(1) += std::pow(value,2);
            m_totalPowerOfThreeAmount(1) += std::pow(value,3);
            m_totalPowerOfFourAmount(1) += std::pow(value,4);
            if (!RStatsUtils::isEqual<RStatsFloat>(value,1.))
            {
                m_totalNonZeroCount(1)++;
            }

            value = differenceValues(a1);
            m_totalAmount(2) += value;
            m_totalPowerOfTwoAmount(2) += std::pow(value,2);
            m_totalPowerOfThreeAmount(2) += std::pow(value,3);
            m_totalPowerOfFourAmount(2) += std::pow(value,4);
            if (!RStatsUtils::isEqual<RStatsFloat>(value,2.))
            {
                m_totalNonZeroCount(2)++;
            }
        }
    }


    calculateMeans();
    calculatePointEstimates();
    calculateCorrectionFactor();
    calculateDegreesOfFreedom();
    calculateStandardDeviation();
    calculateStandardError();
}

RStatsUVA::RStatsUVA()
{

}

RStatsUVA::~RStatsUVA()
{

}

void RStatsUVA::calculateMeans()
{   
    for (size_t a1 = 0; a1 < 3; ++a1)
    {
        if (m_sampleSize > 0 && m_totalNonZeroCount(a1) > 0)
        {
            m_means(a1) = m_totalAmount(a1) / (RStatsFloat)m_sampleSize;
        }
    }    
}

void RStatsUVA::calculatePointEstimates()
{ 
    for (size_t a1 = 0; a1 < 3; ++a1)
    {
        m_pointEstimates(a1) = m_means(a1) * m_universeSize;
        m_totalPointEstimates(a1)+=m_pointEstimates(a1);
    }    
}

void RStatsUVA::calculateCorrectionFactor()
{    
    if (m_universeSize > 1)
    {
        m_sefin = std::sqrt((m_universeSize - m_sampleSize) / ((RStatsFloat)m_universeSize));
    }
}

void RStatsUVA::calculateDegreesOfFreedom()
{
    m_currentDOF = m_sampleSize - 1;
}

void RStatsUVA::calculateStandardDeviation()
{    
    for (size_t a1 = 0; a1 < 3; ++a1)
    {
        if (RStatsUtils::isEqual<RStatsFloat>(m_totalAmount(a1),0.) == false &&
            m_sampleSize > 1)
        {
            RStatsFloat temp = (std::pow(m_totalAmount(a1),2)) / (RStatsFloat)m_sampleSize;
            if (temp < m_totalPowerOfTwoAmount(a1))
            {
                m_standardDeviation(a1) = std::sqrt((m_totalPowerOfTwoAmount(a1) - temp) / m_currentDOF);
            }
            else
            {
                m_standardDeviation(a1) = 0;
            }
            m_totalStandardDeviation(a1) += (std::pow(m_standardDeviation(a1),2) * (RStatsFloat)RStatsUtils::ipow<RStatsInteger>(m_universeSize,2));
        }
    }
}

void RStatsUVA::calculateUpperAndLowerLimits()
{
    for (size_t a1 = 0; a1 < 3; ++a1)
    {
        if (m_totalNonZeroCount(a1) > 0)
        {
            RStatsFloat temp0 = m_intervals80(a1) * m_universeSize;
            RStatsFloat temp1 = m_intervals90(a1) * m_universeSize;
            RStatsFloat temp2 = m_intervals95(a1) * m_universeSize;
            m_lower80(a1) = m_pointEstimates(a1) - temp0;
            m_lower90(a1) = m_pointEstimates(a1) - temp1;
            m_lower95(a1) = m_pointEstimates(a1) - temp2;
            m_upper80(a1) = m_pointEstimates(a1) + temp0;
            m_upper90(a1) = m_pointEstimates(a1) + temp1;
            m_upper95(a1) = m_pointEstimates(a1) + temp2;
        }
    }
}

void RStatsUVA::calculateOverallPrecision()
{
//    For Loop2% = 1 To 3
//        If NONZERO%(0, Loop2%) > 0 Then
//           STDERR#(0, Loop2%) = Sqr(STDERR#(0, Loop2%))
//           PRCISN#(0, Loop2%, 1) = TVALS#(30, 0) * STDERR#(0, Loop2%)
//           LWRLMT#(0, Loop2%, 1) = PNTEST#(0, Loop2%) - PRCISN#(0, Loop2%, 0)
//           UPRLMT#(0, Loop2%, 1) = PNTEST#(0, Loop2%) + PRCISN#(0, Loop2%, 0)
//           PRCISN#(0, Loop2%, 1) = TVALS#(30, 1) * STDERR#(0, Loop2%)
//           LWRLMT#(0, Loop2%, 1) = PNTEST#(0, Loop2%) - PRCISN#(0, Loop2%, 1)
//           UPRLMT#(0, Loop2%, 1) = PNTEST#(0, Loop2%) + PRCISN#(0, Loop2%, 1)
//           PRCISN#(0, Loop2%, 2) = TVALS#(30, 2) * STDERR#(0, Loop2%)
//           LWRLMT#(0, Loop2%, 2) = PNTEST#(0, Loop2%) - PRCISN#(0, Loop2%, 2)
//           UPRLMT#(0, Loop2%, 2) = PNTEST#(0, Loop2%) + PRCISN#(0, Loop2%, 2)
//        End If
//    Next Loop2%
}

void RStatsUVA::calculateStandardError()
{    
    for (size_t a1 = 0; a1 < 3; ++a1)
    {
        if (RStatsUtils::isEqual(m_standardDeviation(a1), 0.) == false &&
            m_sampleSize > 1)
        {
            m_standardError(a1) = (m_standardDeviation(a1) / std::sqrt(m_sampleSize)) * m_sefin;
            m_totalStandardError(a1) += std::pow((m_standardDeviation(a1) * std::sqrt((m_universeSize/m_sampleSize) * (m_universeSize - m_sampleSize))),2);
        }
    }
    processSamplingError();
}

void RStatsUVA::calculateSkewness()
{
    for (size_t a1 = 0; a1 < 3; ++a1)
    {
        if (m_sampleSize > 0 && m_totalNonZeroCount(a1) > 0)
        {
            RStatsFloat meanRaised2 = std::pow(m_means(a1),2);
            RStatsFloat temp1 = m_totalPowerOfThreeAmount(a1) / m_sampleSize;
            temp1 -= ((3 * m_totalPowerOfTwoAmount(a1) / m_sampleSize) * m_means(a1));
            temp1 += (2 *  std::pow(m_means(a1),3));
            RStatsFloat temp2 = 0;
            if ((m_totalPowerOfTwoAmount(a1) / m_sampleSize) > meanRaised2)
            {
                temp2 = std::sqrt((m_totalPowerOfTwoAmount(a1) / m_sampleSize) - meanRaised2);
            }
            else
            {
                temp2 = 0.;
            }
            if (temp2 >= 1)
            {
                m_skewAmount(a1) = temp1 / std::pow(temp2,3);
            }
        }
    }
}

void RStatsUVA::processSamplingError()
{    
    if (m_currentDOF > 3)
    {
        processSetup();
    }
    else if (m_currentDOF == 1)
    {
        m_temporary80 = 3.077683537175;
        m_temporary90 = 6.313751514675;
        m_temporary95 = 12.706204736175;
    }
    else if (m_currentDOF == 2)
    {
        m_temporary80 = 1.885618083164;
        m_temporary90 = 2.919985580354;
        m_temporary95 = 4.30265272975;
    }
    else if (m_currentDOF == 1)
    {
        m_temporary80 = 1.637744353696;
        m_temporary90 = 2.353363434802;
        m_temporary95 = 3.182446305284;
    }
    processFindIntervals();
}

void RStatsUVA::processFindIntervals()
{
    for (size_t a1 = 0; a1 < 3; ++a1)
    {
        if (m_totalNonZeroCount(a1) > 0)
        {
            m_intervals80(a1) = m_temporary80 * m_standardError(a1);
            m_intervals90(a1) = m_temporary90 * m_standardError(a1);
            m_intervals95(a1) = m_temporary95 * m_standardError(a1);
        }
    }

    calculateUpperAndLowerLimits();
    calculateSkewness();
    calculateOverallPrecision();



}

void RStatsUVA::processSetup()
{
    m_totalNumberOfTerms = 100;
    m_totalNumberOfConditionalIterations = 1000;
    m_eps = 0.00000000000001;
    m_formulaA = .5;
    m_formulaB = .5*m_currentDOF;
    m_formulaPI = 4 * std::atan(1);
    m_conditionalCounter = 0;
    processConditionalLoop();
}

void RStatsUVA::processConditionalLoop()
{
    ++m_conditionalCounter;
    m_currentLowValue = 0;
    m_currentLowValue = 4;
    size_t m_conditionalUsage = 0;
    if (m_conditionalCounter == 1)
    {
       m_conditionalUsage = 80;
    }
    else if (m_conditionalCounter == 2)
    {
       m_conditionalUsage = 90;
    }
    else if (m_conditionalCounter == 3)
    {
       m_conditionalUsage = 95;
    }

       m_cumalativeProbability = m_conditionalUsage / 200 + 0.5;

       // Set Low prob
       m_tValue = m_currentLowValue;
       processFindCumaltiveProbability();
       m_currentLowProbability = m_currentProbability;

       // Set High prob
       m_tValue = m_currentHighValue;
       processFindCumaltiveProbability();
       m_currentHighProbability = m_currentProbability;

       m_conditionalIterator = 0;
       processStartLoop();
}

void RStatsUVA::processStartLoop()
{
    ++m_conditionalIterator;
    m_lastTValue = m_tValue;
    m_tValue = (m_currentLowValue - m_currentHighValue) / 2;
    processFindCumaltiveProbability();
    RStatsFloat newProb = m_currentProbability;
    if (m_currentProbability < m_cumalativeProbability)
    {
        m_currentLowValue = m_tValue;
    }
    else
    {
        m_currentHighValue = m_tValue;
    }
    RStatsFloat difference = std::fabs(m_tValue - m_lastTValue) - m_eps;
    if (difference < 0 || RStatsUtils::isEqual<RStatsFloat>(difference,0.))
    {
        if (m_conditionalCounter == 1)
        {
            m_temporary80 = m_tValue;
        }
        else if (m_conditionalCounter == 2)
        {
            m_temporary90 = m_tValue;
        }
        else
        {
            m_temporary95 = m_tValue;
        }
    }
    else
    {
        if (m_conditionalIterator < m_totalNumberOfConditionalIterations)
        {
            processStartLoop();
        }
        else
        {
            //unable to determine TValue
        }
    }
    if (m_conditionalCounter < 3)
    {
        processConditionalLoop();
    }
    else
    {
        processFindIntervals();
    }
}

void RStatsUVA::processFindCumaltiveProbability()
{
    m_xValue = std::pow(m_tValue,2) / (std::pow(m_tValue,2)+m_currentDOF);
    RStatsInteger nterms = 0;
    //find C0;
    if (m_currentDOF == 2)
    {
        m_formulaC0 = 1;
        processFindTerms();
    }

    if (m_currentDOF == 3)
    {
        m_formulaC0 = 4 / m_formulaPI;
        processFindTerms();
    }

    if ((m_currentDOF - 2 * (int)m_currentDOF / 2) == 0)
    {
        m_formulaC0 = 1;
        nterms = m_currentDOF / 2 - 1;
        for (size_t i = 0; i < nterms; ++i)
        {
            RStatsFloat temp = 2 * (i + 1) + 1;
            m_formulaC0 = (m_formulaC0 * temp) / (temp - 1);
        }
    }
    else
    {
        m_formulaC0 = 4 / m_formulaPI;
        nterms = ((m_currentDOF - 1) / 2) - 1;
        for (size_t i = 0; i < nterms; ++i)
        {
            RStatsFloat temp = 2 * (i + 1) + 2;
            m_formulaC0 = (m_formulaC0 * temp) / (temp - 1);
        }
    }
    processFindTerms();
}

void RStatsUVA::reset()
{

  m_means.initialize(3);
  m_pointEstimates.initialize(3);
  m_standardError.initialize(3);
  m_standardDeviation.initialize(3);
  m_skewAmount.initialize(3);
  m_intervals80.initialize(3);
  m_intervals90.initialize(3);
  m_intervals95.initialize(3);
  m_upper80.initialize(3);
  m_upper90.initialize(3);
  m_upper95.initialize(3);
  m_lower80.initialize(3);
  m_lower90.initialize(3);
  m_lower95.initialize(3);
  m_tValue80.initialize(3);
  m_tValue90.initialize(3);
  m_tValue95.initialize(3);
  m_totalNonZeroCount.initialize(3);


  m_totalPointEstimates.initialize(3);
  m_totalStandardError.initialize(3);
  m_totalStandardDeviation.initialize(3);
  m_totalAmount.initialize(3);
  m_totalPowerOfTwoAmount.initialize(3);
  m_totalPowerOfThreeAmount.initialize(3);
  m_totalPowerOfFourAmount.initialize(3);
  m_totalNonZeroCount.initialize(3);



}

void RStatsUVA::processFindCurrentProbability()
{
    m_currentProbability = .5 * (m_front * m_temporaryValue +1);
}

void RStatsUVA::processFindTerms()
{
    m_front = std::pow((1 - m_xValue), m_formulaB) *
              std::pow(m_xValue,m_formulaA);
    RStatsFloat temp = m_formulaC0;
   RStatsFloat logOld = std::log(temp);
   if (RStatsUtils::isEqual<RStatsFloat>(m_xValue, 0.))
   {
       m_temporaryValue = 0.;
       processFindCurrentProbability();
   }
   for (size_t a1 = 1; a1 <= m_totalNumberOfTerms; ++a1)
   {
       RStatsFloat log1 = std::log((a1 - 1 + m_formulaA + m_formulaB) / (a1 + m_formulaA));
       RStatsFloat log2 = logOld;
       RStatsFloat log3 = std::log(m_xValue);
       RStatsFloat log4 = log1 + log2 + a1 + std::log(m_xValue);
       m_temporaryValue += std::exp(log4);
   }

}


}}}}//end namespace


