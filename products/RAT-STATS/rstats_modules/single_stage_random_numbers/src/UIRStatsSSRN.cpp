/*
    UIRStatsSSRN.cpp   
*/
//UIRStatsSSRN.cpp generated by CBTek Solutions on 02-23-2017 at 08:00:38 PM

#include "UIRStatsSSRN.h"
#include "ui_UIRStatsSSRN.h"

#include "RStatsSSRN.h"

#include "rstats_ui/inc/UIRStatsAbout.h"
#include "rstats_ui/inc/UIRStatsUtils.hpp"
#include "rstats_ui/inc/UIRStatsErrorMessage.h"

#include "utility/inc/DateTimeUtils.hpp"
#include "utility/inc/XMLUtils.h"
#include "utility/inc/FileUtils.hpp"
#include "utility/inc/SystemUtils.hpp"

#include <QDoubleValidator>
#include <QIntValidator>
#include <QFileDialog>
#include <QFile>
#include <QDesktopServices>

using namespace oig::ratstats::ui;
using namespace oig::ratstats::utils;
using namespace cbtek::common::utility;

namespace oig {
namespace ratstats {
namespace modules {
namespace ssrn {

UIRStatsSSRN::UIRStatsSSRN(QWidget *parent) :
    QMainWindow(parent),
    m_ui(new Ui_UIRStatsSSRN)
{
    m_ui->setupUi(this);

    //Remove title bar from options dock
    m_ui->m_dockOptions->setTitleBarWidget(new QWidget());    

    //Set icons used by validation console
    m_iconError = UIRStatsUtils::getIcon("img_error.png");
    m_iconOK = UIRStatsUtils::getIcon("img_ok.png");
    m_iconWarning = UIRStatsUtils::getIcon("img_warning.png");

    // Add floating point validator
    QIntValidator * validatorForFrame = new QIntValidator;
    QIntValidator * validatorForValues = new QIntValidator;
    validatorForValues->setBottom(0);

    m_ui->m_txtSeed->setValidator( new QDoubleValidator(this) );
    m_ui->m_txtSpares->setValidator( validatorForValues );
    m_ui->m_txtOrder->setValidator( validatorForValues );
    m_ui->m_txtHighNumber->setValidator( validatorForFrame );
    m_ui->m_txtLowNumber->setValidator( validatorForFrame );

    //Initialize all menu actions with icons and shortcuts
    UIRStatsUtils::initButton(m_ui->m_btnExecute, "img_run.png");
    UIRStatsUtils::initButton(m_ui->m_btnExit, "img_exit.png");
    UIRStatsUtils::initButton(m_ui->m_btnHelp, "img_help.png");
    UIRStatsUtils::initAction(m_ui->actionAbout,"img_about.png","Alt+A");
    UIRStatsUtils::initAction(m_ui->actionNew_Window,"img_add.png","Alt+N");
    UIRStatsUtils::initAction(m_ui->actionExecute,"img_run.png","Alt+E");
    UIRStatsUtils::initAction(m_ui->actionExit,"img_exit.png","Alt+Q");
    UIRStatsUtils::initAction(m_ui->actionHelp,"img_help.png","Alt+H");
    UIRStatsUtils::initAction(m_ui->actionRecent,"img_clock.png","Alt+R");
    m_ui->menuFile->setTitle("&File");
    m_ui->menuHelp->setTitle("&Help");

    //Connect all buttons/actions to event functions
    connect(m_ui->actionExecute,SIGNAL(triggered(bool)),this,SLOT(onExecute()));
    connect(m_ui->actionExit,SIGNAL(triggered(bool)),this,SLOT(onExit()));
    connect(m_ui->actionHelp,SIGNAL(triggered(bool)),this,SLOT(onHelp()));
    connect(m_ui->actionAbout,SIGNAL(triggered(bool)),this,SLOT(onAbout()));
    connect(m_ui->actionNew_Window,SIGNAL(triggered(bool)),this,SLOT(onLaunchNewWindow()));
    connect(m_ui->m_btnExit,SIGNAL(clicked(bool)),this,SLOT(onExit()));
    connect(m_ui->m_btnExecute,SIGNAL(clicked(bool)),this,SLOT(onExecute()));    
    connect(m_ui->m_btnHelp,SIGNAL(clicked(bool)),this,SLOT(onHelp()));
    connect(m_ui->m_txtAuditName,SIGNAL(textEdited(QString)),SLOT(onUpdateValidation()));
    connect(m_ui->m_txtSeed,SIGNAL(textEdited(QString)),SLOT(onUpdateValidation()));
    connect(m_ui->m_txtHighNumber,SIGNAL(textEdited(QString)),this,SLOT(onUpdateValidation()));
    connect(m_ui->m_txtLowNumber,SIGNAL(textEdited(QString)),this,SLOT(onUpdateValidation()));
    connect(m_ui->m_txtSpares,SIGNAL(textEdited(QString)),this,SLOT(onUpdateValidation()));
    connect(m_ui->m_txtOrder,SIGNAL(textEdited(QString)),this,SLOT(onUpdateValidation()));
    connect(m_ui->m_chkCSVOutput,SIGNAL(clicked(bool)),this,SLOT(onSaveCSVFile()));
    connect(m_ui->m_chkXLSOutput,SIGNAL(clicked(bool)),this,SLOT(onSaveXLSFile()));
    connect(m_ui->m_chkTextOutput,SIGNAL(clicked(bool)),this,SLOT(onSaveTextFile()));    
    connect(m_ui->m_grpCustomSeed,SIGNAL(toggled(bool)),this,SLOT(onSeedBoxToggled(bool)));
    m_autoSetFileOutput = false;

    //Set default values
    m_ui->m_txtSpares->setText("0");
    m_ui->m_txtOrder->setText("0");
    m_ui->m_txtHighNumber->setText("0");
    m_ui->m_txtLowNumber->setText("0");

    //Create default audit name
    QString defaultAuditName = QString::fromStdString(RStatsUtils::getAuditName());
    m_ui->m_txtAuditName->setPlaceholderText(defaultAuditName);

    //Generate random seed    
    double seed = static_cast<RStatsFloat>(TimeUtils::getSecondsNow()) /
            static_cast<RStatsFloat>(m_rnd.next(10,1000));
    m_ui->m_txtSeed->setText(QString::fromStdString(StringUtils::toString(seed,6)));

    //Set output labels to null
    m_currentCSVFileOutputLabel = nullptr;
    m_currentTextFileOutputLabel = nullptr;
    m_currentXLSFileOutputLabel = nullptr;

    //Hide the main output groupbox
    m_ui->m_grpOutput->hide();

    //Update recently used sessions
    updateRecentSessions();

    //Toggle the custom seed checkbox to false
    onSeedBoxToggled(false);

    //Call the validator
    onValidate();
}

void UIRStatsSSRN::onExecute()
{
    //Update validation console and first error if validation fails
    if (!onValidate())
    {
        UIRStatsUtils::highlightErrorInValidationConsole(m_ui->m_lstValidationConsole);
        return;
    }

    try
    {
        onUpdateSeed();

        //Make sure the audit name is correct
        std::string name = m_ui->m_txtAuditName->text().toStdString();
        if (StringUtils::isEmpty(name))
        {
            name = m_ui->m_txtAuditName->placeholderText().toStdString();
        }

        //Get the high/low/order/spare values
        std::int64_t low  = m_ui->m_txtLowNumber->text().toInt();
        std::int64_t high = m_ui->m_txtHighNumber->text().toInt();
        std::int64_t order= m_ui->m_txtOrder->text().toInt();
        std::int64_t spare= m_ui->m_txtSpares->text().toInt();

        //Execute primary function for single stage random numbers
        RStatsSSRN ssrn;
        ssrn.execute(name,
                     m_ui->m_txtSeed->text().remove(",").toStdString(),
                     order,
                     spare,
                     low,
                     high);

        //Save results to a worksheet
        RStatsWorksheet worksheet;
        ssrn.saveToWorksheet(worksheet);

        //Save output to view
        std::string htmlContent = worksheet.toHTMLTableString();
        m_ui->m_txtOutput->setHtml(QString::fromStdString(htmlContent));


        //Show results in browser if selected
        if (m_ui->m_chkViewInBrowser->isChecked())
        {
            UIRStatsUtils::launchHtml(htmlContent);
        }

        size_t row = worksheet.getNumRows();

        //Save CSV file, if applicable
        if (m_ui->m_chkCSVOutput->isChecked())
        {
            worksheet(row,0) = "CSV File:";
            worksheet(row,1) = m_currentCSVFileOutput.toStdString();
            FileUtils::writeFileContents(m_currentCSVFileOutput.toStdString(),worksheet.toCommaDelimitedString());
        }

        //Save Text file, if applicable
        if (m_ui->m_chkTextOutput->isChecked())
        {
            worksheet(row,0) = "Text File:";
            worksheet(row,1) = m_currentTextFileOutput.toStdString();
            FileUtils::writeFileContents(m_currentTextFileOutput.toStdString(),worksheet.toEvenlySpacedString());
        }

        //Save XLS file (for Excel/Access), if applicable
        if (m_ui->m_chkXLSOutput->isChecked())
        {
            RStatsWorkbook workbook;
            worksheet(row,0) = "XLS File:";
            worksheet(row,1) = m_currentXLSFileOutput.toStdString();
            workbook.addWorksheet(worksheet);
            workbook.save(m_currentXLSFileOutput.toStdString());
        }

        //Show the output group box
        m_ui->m_grpOutput->show();

        //Hide the "No Data" label
        m_ui->m_lblNoData->hide();

        //Save the user session data for this run
        RStatsSSRNSessionData sessionData = getSessionData();
        sessionData.setCreationDate(DateUtils::getCurrentDate().toDateInteger());
        sessionData.setCreationTime(TimeUtils::getCurrentTime().toTimeInteger());
        m_recentSessionsMap[sessionData.getSessionId()]=RStatsModuleSessionDataPtr(new RStatsSSRNSessionData(sessionData));
        RStatsUtils::saveRecentSession(m_recentSessionsMap[sessionData.getSessionId()]);
        updateRecentSessions();
    }
    catch (std::exception& e)
    {
        UIRStatsErrorMessage("Error occured while executing \""+this->windowTitle().toStdString()+"\"",
                             std::string(e.what()),false,this).exec();
        return;
    }
}


UIRStatsSSRN::~UIRStatsSSRN()
{
    delete m_ui;
}

bool UIRStatsSSRN::





onValidate()
{
    //Clear the validation console and logger
    m_conditionLogger.clear();
    m_ui->m_lstValidationConsole->clear();

    //Get the high/low/order/spare values    
    std::int64_t low  = m_ui->m_txtLowNumber->text().toInt();
    std::int64_t high = m_ui->m_txtHighNumber->text().toInt();
    std::int64_t order= m_ui->m_txtOrder->text().toInt();
    std::int64_t spare= m_ui->m_txtSpares->text().toInt();

    //Add validation warnings

    m_conditionLogger.addWarning(spare+order > 10000,
                                 "Total number of random values exceeds data limitation(10,000) imposed by RAT-STATS 2010.");


    m_conditionLogger.addWarning(m_ui->m_txtAuditName->text().isEmpty(),
                        "You did not specify an audit name.  Using default: ("+m_ui->m_txtAuditName->placeholderText().toStdString()+")");

    m_conditionLogger.addWarning(low == high,
                        "The low number is equal to the high number!");

    m_conditionLogger.addWarning((order + spare > 10000),
                        "Total number of values to be generated exceed 10,000.  RAT-STATS 2017 will still work but this value exceeds data limits of previous versions.");

    //Add validation errors
    m_conditionLogger.addError(((order + spare) == 0 ),
                      "The number of generated values must be greater than zero!");

    m_conditionLogger.addError(low > high,
                      "The low number is greater than or equal to the high number!");

    m_conditionLogger.addError(((high - low) + 1)  < (order + spare),
                        "The sampling frame is less than the total number of values to be generated!");

    //If condition logger has no messages then hide the dock and
    //return true
    size_t index = 0;
    if (m_conditionLogger.hasMessages() == false)
    {
        m_ui->m_dockValidationConsole->hide();
        return true;
    }

    //If messages exist then show the validation console
    m_ui->m_dockValidationConsole->show();

    //Add messages to validation console
    for(const std::string & message : m_conditionLogger.getMessages())
    {
        QListWidgetItem * item = new QListWidgetItem;
        item->setText(QString::fromStdString(message));
        if (m_conditionLogger.isError(index))
        {
            item->setIcon(m_iconError);
        }
        else if (m_conditionLogger.isWarning(index))
        {
            item->setIcon(m_iconWarning);
        }
        else
        {
            item->setIcon(m_iconOK);
        }
        ++index;
        m_ui->m_lstValidationConsole->addItem(item);
    }

    //Return true if there are warnings but no errors
    if (m_conditionLogger.hasError())
    {        
        return false;
    }
    else
    {        
        return true;
    }
}

void UIRStatsSSRN::onSaveCSVFile()
{
    if (m_autoSetFileOutput)return;
    if (m_ui->m_chkCSVOutput->isChecked())
    {
        m_currentCSVFileOutput = UIRStatsUtils::setOutputFile(
                                                              m_ui->m_chkCSVOutput,
                                                              "Save to CSV file...",
                                                              "*.csv");
        setCSVFileOutput(m_currentCSVFileOutput.toStdString());
    }
    else m_ui->m_statusBar->removeWidget(m_currentCSVFileOutputLabel);
}

void UIRStatsSSRN::onSaveTextFile()
{
    if (m_autoSetFileOutput)return;
    if (m_ui->m_chkTextOutput->isChecked())
    {
        m_currentTextFileOutput = UIRStatsUtils::setOutputFile(
                                                               m_ui->m_chkTextOutput,
                                                               "Save to Text file...",
                                                               "*.txt");
        setTextFileOutput(m_currentTextFileOutput.toStdString());
    }
    else m_ui->m_statusBar->removeWidget(m_currentTextFileOutputLabel);
}

void UIRStatsSSRN::onSaveXLSFile()
{
    if (m_autoSetFileOutput) return;
    if (m_ui->m_chkXLSOutput->isChecked())
    {
        m_currentXLSFileOutput = UIRStatsUtils::setOutputFile(
                                                              m_ui->m_chkXLSOutput,
                                                              "Save to XLS file...",
                                                              "*.xls");
        setXLSFileOutput(m_currentXLSFileOutput.toStdString());
    }
    else m_ui->m_statusBar->removeWidget(m_currentXLSFileOutputLabel);
    onValidate();
}

void UIRStatsSSRN::onUpdateSeed()
{
    if (!m_ui->m_grpCustomSeed->isChecked() && !m_ui->m_txtSeed->isEnabled())
    {        
        double seed = static_cast<RStatsFloat>(TimeUtils::getSecondsNow()) /
                static_cast<RStatsFloat>(m_rnd.next(10,1000));
        m_ui->m_txtSeed->setText(QString::fromStdString(StringUtils::toString(seed,6)));
    }
}


void UIRStatsSSRN::onHelp()
{    
    UIRStatsUtils::launchHelp("rstats_ssrn.pdf");
}

void UIRStatsSSRN::onAbout()
{
    UIRStatsAbout().exec();
}

void UIRStatsSSRN::onExit()
{
    this->close();
}


RStatsSSRNSessionData UIRStatsSSRN::getSessionData() const
{
    QString text = m_ui->m_txtAuditName->text();
    if (text.isEmpty())
    {
        text = m_ui->m_txtAuditName->placeholderText();
    }
    std::int64_t low  = m_ui->m_txtLowNumber->text().toInt();
    std::int64_t high = m_ui->m_txtHighNumber->text().toInt();
    std::int64_t order= m_ui->m_txtOrder->text().toInt();
    std::int64_t spare= m_ui->m_txtSpares->text().toInt();

    RStatsSSRNSessionData data;
    data.setAuditName(text.toStdString());
    data.setCSVOutputFile(m_currentCSVFileOutput.toStdString());
    data.setXLSOutputFile(m_currentXLSFileOutput.toStdString());
    data.setTextOutputFile(m_currentTextFileOutput.toStdString());
    data.setSeed(m_ui->m_txtSeed->text().toStdString());
    data.setOrder(order);
    data.setSpares(spare);
    data.setLow(low);
    data.setHigh(high);
    data.setViewInBrowserFlag(m_ui->m_chkViewInBrowser->isChecked());
    return data;
}

void UIRStatsSSRN::setSessionData(const RStatsSSRNSessionData &data)
{
    m_ui->m_chkViewInBrowser->setChecked(data.isViewableInBrowser());
    m_ui->m_grpCustomSeed->setChecked(true);
    m_ui->m_txtAuditName->setText(QString::fromStdString(data.getAuditName()));
    m_ui->m_txtSeed->setText(QString::fromStdString(data.getSeed()));
    m_ui->m_txtSeed->setEnabled(true);
    m_ui->m_txtHighNumber->setText(QString::number(static_cast<std::int64_t>(data.getHigh())));
    m_ui->m_txtLowNumber->setText(QString::number(static_cast<std::int64_t>(data.getLow())));
    m_ui->m_txtSpares->setText(QString::number(static_cast<std::int64_t>(data.getSpares())));
    m_ui->m_txtOrder->setText(QString::number(static_cast<std::int64_t>(data.getOrder())));

    m_autoSetFileOutput=true;
    if (!data.getCSVOutputFile().empty())
    {
        m_ui->m_chkCSVOutput->setChecked(true);
        setCSVFileOutput(data.getCSVOutputFile());
        m_ui->m_chkCSVOutput->setToolTip(QString::fromStdString(data.getCSVOutputFile()));
    }

    if (!data.getXLSOutputFile().empty())
    {
        m_ui->m_chkXLSOutput->setChecked(true);
        setXLSFileOutput(data.getXLSOutputFile());
        m_ui->m_chkXLSOutput->setToolTip(QString::fromStdString(data.getXLSOutputFile()));
    }

    if (!data.getTextOutputFile().empty())
    {
        m_ui->m_chkTextOutput->setChecked(true);
        setTextFileOutput(data.getTextOutputFile());
        m_ui->m_chkTextOutput->setToolTip(QString::fromStdString(data.getTextOutputFile()));
    }
    m_autoSetFileOutput=false;
}
void UIRStatsSSRN::onClearRecentSessions()
{
    RStatsUtils::clearRecentSessions(c_RECENT_SESSION_EXTENSION);        
    updateRecentSessions();
}

void UIRStatsSSRN::onRecentSessionSelected(QAction *action)
{
    std::string id = action->property("id").toString().toStdString();
    if (m_recentSessionsMap.count(id))
    {
        RStatsSSRNSessionData * data = dynamic_cast<RStatsSSRNSessionData*>(m_recentSessionsMap[id].get());
        if (data)
        {
            setSessionData(*data);
        }
    }
    onValidate();
}

void UIRStatsSSRN::updateRecentSessions()
{
    std::pair<QActionGroup*,QAction*> actionPair=UIRStatsUtils::buildRecentSessions<RStatsSSRNSessionData>(
                                                 this,
                                                 m_ui->actionRecent,
                                                 this->m_recentSessionsMap,
                                                 c_RECENT_SESSION_EXTENSION);


    if (actionPair.first && actionPair.second)
    {
        connect(actionPair.first,SIGNAL(triggered(QAction*)),this,SLOT(onRecentSessionSelected(QAction*)));
        connect(actionPair.second,SIGNAL(triggered(bool)),this,SLOT(onClearRecentSessions()));
    }

}

void UIRStatsSSRN::onSeedBoxToggled(bool toggle)
{
    if (toggle)
    {
        m_ui->m_txtSeed->setEnabled(true);
        m_ui->m_txtSeed->clear();
        m_ui->m_txtSeed->setFocus();
    }
    else
    {     
        m_ui->m_txtSeed->setEnabled(false);
        onUpdateSeed();
    }

}

void UIRStatsSSRN::setTextFileOutput(const std::string& textFile)
{
    m_currentTextFileOutput = QString::fromStdString(textFile);
    if (!m_currentTextFileOutput.isEmpty())
    {
        if (m_currentTextFileOutputLabel == nullptr)
        {
            m_currentTextFileOutputLabel = new QLabel;
            m_currentTextFileOutputLabel->setStyleSheet("QLabel{padding:2px;border-radius:5px;background:#FFAAFF;color:#000000;border:1px solid grey;}");

        }
        else m_ui->m_statusBar->removeWidget(m_currentTextFileOutputLabel);

        m_currentTextFileOutputLabel->setToolTip(m_currentTextFileOutput);
        QString text = "<b>Text File:</b> "+m_currentTextFileOutput;
        QFontMetrics metrics(this->font());
        QString elidedText = metrics.elidedText(text, Qt::ElideMiddle, this->width() / 2);
        m_currentTextFileOutputLabel->setText(elidedText);

        m_ui->m_statusBar->addPermanentWidget(m_currentTextFileOutputLabel);
        m_currentTextFileOutputLabel->show();
    }
    else m_ui->m_statusBar->removeWidget(m_currentTextFileOutputLabel);
}

void UIRStatsSSRN::onLaunchNewWindow()
{
    (new UIRStatsSSRN(nullptr))->show();
}

void UIRStatsSSRN::onUpdateValidation()
{
    onValidate();
}

void UIRStatsSSRN::setCSVFileOutput(const std::string& csvFile)
{
    m_currentCSVFileOutput = QString::fromStdString(csvFile);
    if (!m_currentCSVFileOutput.isEmpty())
    {
        if (m_currentCSVFileOutputLabel == nullptr)
        {
            m_currentCSVFileOutputLabel = new QLabel;
            m_currentCSVFileOutputLabel->setStyleSheet("QLabel{padding:2px;border-radius:5px;background:#AAFFFF;color:#000000;border:1px solid grey;}");
        }
        else m_ui->m_statusBar->removeWidget(m_currentCSVFileOutputLabel);
        m_currentCSVFileOutputLabel->setToolTip(m_currentCSVFileOutput);
        QString text = "<b>CSV File:</b> "+m_currentCSVFileOutput;
        QFontMetrics metrics(this->font());
        QString elidedText = metrics.elidedText(text, Qt::ElideMiddle, this->width() / 2);
        m_currentCSVFileOutputLabel->setText(elidedText);

        m_ui->m_statusBar->addPermanentWidget(m_currentCSVFileOutputLabel);
        m_currentCSVFileOutputLabel->show();
    }
    else m_ui->m_statusBar->removeWidget(m_currentCSVFileOutputLabel);
}

void UIRStatsSSRN::setXLSFileOutput(const std::string& xlsFile)
{
    m_currentXLSFileOutput = QString::fromStdString(xlsFile);
    if (!m_currentXLSFileOutput.isEmpty())
    {
        if (m_currentXLSFileOutputLabel == nullptr)
        {
            m_currentXLSFileOutputLabel = new QLabel;
            m_currentXLSFileOutputLabel->setStyleSheet("QLabel{padding:2px;border-radius:5px;background:#AAAAFF;color:#000000;border:1px solid grey;}");
        }
        else m_ui->m_statusBar->removeWidget(m_currentXLSFileOutputLabel);
        m_currentXLSFileOutputLabel->setToolTip(m_currentXLSFileOutput);
        QString text = "<b>XLS File:</b> "+m_currentXLSFileOutput;
        QFontMetrics metrics(this->font());
        QString elidedText = metrics.elidedText(text, Qt::ElideMiddle, this->width() / 2);
        m_currentXLSFileOutputLabel->setText(elidedText);

        m_ui->m_statusBar->addPermanentWidget(m_currentXLSFileOutputLabel);
        m_currentXLSFileOutputLabel->show();
    }
    else m_ui->m_statusBar->removeWidget(m_currentXLSFileOutputLabel);
}

void UIRStatsSSRN::resizeEvent(QResizeEvent *)
{
    if (m_currentCSVFileOutputLabel)
    {
        setCSVFileOutput(m_currentCSVFileOutput.toStdString());
    }
    if (m_currentTextFileOutputLabel)
    {
        setTextFileOutput(m_currentTextFileOutput.toStdString());
    }
}
}}}}//end namespace

