/*
    UIRStatsMain.cpp
    

*/
//UIRStatsMain.cpp generated by CBTek Solutions on 02-03-2017 at 12:29:37 AM

#include <QDebug>
#include <QIcon>
#include <QGroupBox>
#include <QPushButton>
#include <QScrollArea>
#include <QFontMetrics>
#include <QLabel>
#include <QProcess>
#include <QMessageBox>
#include <QKeySequence>
#include <QTableWidgetItem>
#include <QPainter>
#include <QFontDatabase>
#include <QDesktopServices>

#include "UIRStatsMain.h"
#include "ui_UIRStatsMain.h"

#include "utility/inc/XMLUtils.h"
#include "utility/inc/FileUtils.hpp"
#include "utility/inc/SystemUtils.hpp"

#include "rstats_utils/inc/RStatsSettingsManager.h"
#include "rstats_utils/inc/RStatsModuleProperties.h"
#include "rstats_utils/inc/RStatsUtils.hpp"
#include "rstats_utils/inc/RStatsWorkbook.h"

#include "rstats_ui/inc/UIRStatsAbout.h"
#include "rstats_ui/inc/UIRStatsErrorMessage.h"
#include "rstats_ui/inc/UIRStatsLaunchConfigDialog.h"
#include "rstats_ui/inc/UIRStatsSettingsManager.h"
#include "rstats_ui/inc/UIRStatsUtils.hpp"

using namespace cbtek::common::utility;
using namespace oig::ratstats::ui;
using namespace oig::ratstats::utils;

namespace oig {
namespace ratstats {
namespace main {

UIRStatsMain::UIRStatsMain(QWidget *parent) :
    QMainWindow(parent),
    m_ui(new Ui_UIRStatsMain)
{    
    m_ui->setupUi(this);                 
    std::uint64_t start = TimeUtils::getCurrentMilliseconds();
    //Set default labels for category list and module list
    onUpdateTableHeader(false);
    m_ui->m_lstModuleCategories->setFocus();

    //Set images for all icons
    m_iconFolder = UIRStatsUtils::getIcon("img_folder.png");
    m_iconModule = UIRStatsUtils::getIcon("img_module.png");
    m_iconEdit = UIRStatsUtils::getIcon("img_edit.png");    
    m_iconAdd = UIRStatsUtils::getIcon("img_add.png");            
    m_iconRemove = UIRStatsUtils::getIcon("img_remove.png");
    m_iconOk = UIRStatsUtils::getIcon("img_ok.png");
    m_iconError = UIRStatsUtils::getIcon("img_error.png");
    m_iconRun = UIRStatsUtils::getIcon("img_run.png");

    //Set icons to actions/buttons
    UIRStatsUtils::initAction(m_ui->m_actionSettings_Manager,"img_settings.png","Alt+S");
    UIRStatsUtils::initAction(m_ui->m_actionExit,"img_exit.png","Alt+Q");
    UIRStatsUtils::initAction(m_ui->m_actionAbout_RAT_STATS_2017,"img_about.png","Alt+A");
    UIRStatsUtils::initAction(m_ui->m_actionHelp_Topics,"img_help.png","Alt+H");
    UIRStatsUtils::initAction(m_ui->m_actionAdd_New_Module,"img_add.png","Alt+N");

    //Set default values
    m_buttonHeight = 40;
    m_currentTable = nullptr;
    m_tableHasFocus = false;
    m_ui->m_lstModuleCategories->setStyleSheet("QListWidget:item{height:"+QString::number(m_buttonHeight)+"px;padding:1px;}");
    m_ui->m_lstModuleCategories->setIconSize(QSize(16,16));
    onInitialize(0);

    //Create SIGNAL/SLOT connections for all actions/buttons and other widgets
    connect(m_ui->m_actionExit,SIGNAL(triggered(bool)),this,SLOT(onExit()));
    connect(m_ui->m_actionHelp_Topics,SIGNAL(triggered(bool)),this,SLOT(onLaunchHelp()));
    connect(m_ui->m_actionSettings_Manager,SIGNAL(triggered(bool)),this,SLOT(onLaunchSettingsManager()));
    connect(m_ui->m_actionAbout_RAT_STATS_2017,SIGNAL(triggered(bool)),this,SLOT(onLaunchAbout()));
    connect(m_ui->m_actionAdd_New_Module,SIGNAL(triggered(bool)),this,SLOT(onAddNewModule()));
    connect(m_ui->m_lstModuleCategories,SIGNAL(currentRowChanged(int)),this,SLOT(onCategoryChanged(int)));
}

UIRStatsMain::~UIRStatsMain()
{
    delete m_ui;
}

void UIRStatsMain::onInitialize(int defaultCategoryIndex)
{    
    //Clear all launch buttons
    m_allLaunchButtons.clear();

    //Clear all button maps
    clearButtonMaps();

    //Clear modules
    m_ui->m_lstModuleCategories->clear();

    m_groupedModules.clear();
    //Grab the modules
    std::vector<RStatsModuleProperties> propsList;
    try
    {
         propsList = RStatsUtils::getModulePropertiesList();
    }
    catch (...)
    {
        RStatsUtils::createValidPath("config/.rstats_module_properties");
        RStatsUtils::createValidPath("config/.rstats_script_provider_properties");
        UIRStatsErrorMessage("No modules detected", "You have no modules available to launch.\nYou may create modules by pressing [Alt + N] or by clicking the \"Create new Module\" link in the file menu").exec();
        return;
    }

    //Loop over modules and determine which groups they belong to    
    for(const RStatsModuleProperties& props : propsList)
    {
        std::string category = props.getCategory();
        if (StringUtils::trimmed(category).size()==0)
        {
            category = "Uncategorized";
        }        
        m_groupedModules[category].push_back(props);
    }

    //Lets loop over all modules by group and populate the module tables
    size_t tableIndex = 0;    
    size_t totalItemCount = 0;
    for (const auto& it : m_groupedModules)
    {
        //Initialize button groups and table to hold module items
        QString name = QString::fromStdString(it.first);                
        m_launchButtonMap[tableIndex] = new QButtonGroup;
        m_editButtonMap[tableIndex] = new QButtonGroup;
        m_removeButtonMap[tableIndex] = new QButtonGroup;
        QButtonGroup * launchButtons = m_launchButtonMap[tableIndex];
        QButtonGroup * editButtons = m_editButtonMap[tableIndex];
        QButtonGroup * removeButtons = m_removeButtonMap[tableIndex];
        QListWidgetItem * moduleParent = new QListWidgetItem;
        moduleParent->setText(name);                        
        m_ui->m_lstModuleCategories->addItem(moduleParent);
        ++tableIndex;
        connect(launchButtons,SIGNAL(buttonClicked(QAbstractButton*)),this,SLOT(onLaunchModule(QAbstractButton*)));
        connect(editButtons,SIGNAL(buttonClicked(QAbstractButton*)),this,SLOT(onEditModule(QAbstractButton*)));
        connect(removeButtons,SIGNAL(buttonClicked(QAbstractButton*)),this,SLOT(onRemoveModule(QAbstractButton*)));
    }
    if (defaultCategoryIndex < m_ui->m_lstModuleCategories->count())
    {
        QListWidgetItem * item = m_ui->m_lstModuleCategories->item(defaultCategoryIndex);

        if (item)
        {
            m_ui->m_lstModuleCategories->setCurrentItem(item);
        }
    }
    onRepopulateModules(m_groupedModules[m_ui->m_lstModuleCategories->currentItem()->text().toStdString()]);
}


QString UIRStatsMain::getKeyAssignment(int count, bool isLaunch, bool isEdit, bool isRemove) const
{

    //Setup unique shortcut for up to 288 modules
    if (isLaunch)
    {
        QString keyString;
        if (count < 36)
        {
            keyString = "Shift+Ctrl";
        }
        else if (count >= 36 && count < 72)
        {
            count-=36;
            keyString = "Shift+Alt";
        }

        else if (count >= 72 && count < 108)
        {
            count-=72;
            keyString = "Alt+Ctrl";
        }

        else if (count >= 108 && count < 144)
        {
            count-=108;
            keyString = "Ctrl+Shift";

        }
        else if (count >= 144 && count < 180)
        {
            count-=144;
            keyString = "Alt+Shift";
        }
        else if (count >= 180 && count < 216)
        {
            count-=180;
            keyString = "Alt+Space";
        }
        else if (count >= 216 && count < 252)
        {
            count-=216;
            keyString = "Ctrl+Space";
        }
        else if (count >= 252 && count < 288)
        {
            count-=252;
            keyString = "Shift+Space";
        }
        if (count < 9)
        {
             keyString+= "+"+QString::fromStdString(std::to_string((count+1)));
        }
        else
        {
            std::string label = RStatsUtils::getColumnLabelFromIndex(static_cast<size_t>(count-9));
            keyString+= "+"+QString::fromStdString(label);
        }
        return keyString;
    }
    else if (isEdit)
    {
        QString keyString;
        if (count < 36)
        {
            keyString = "Shift+F1";
        }
        else if (count >= 36 && count < 72)
        {
            count-=36;
            keyString = "Shift+Alt";
        }

        else if (count >= 72 && count < 108)
        {
            count-=72;
            keyString = "Alt+Ctrl";
        }

        else if (count >= 108 && count < 144)
        {
            count-=108;
            keyString = "Ctrl+Shift";

        }
        else if (count >= 144 && count < 180)
        {
            count-=144;
            keyString = "Alt+Shift";
        }
        else if (count >= 180 && count < 216)
        {
            count-=180;
            keyString = "Alt+Space";
        }
        else if (count >= 216 && count < 252)
        {
            count-=216;
            keyString = "Ctrl+Space";
        }
        else if (count >= 252 && count < 288)
        {
            count-=252;
            keyString = "Shift+Space";
        }
        if (count < 9)
        {
             keyString+= "+"+QString::fromStdString(std::to_string((count+1)));
        }
        else
        {
            std::string label = RStatsUtils::getColumnLabelFromIndex(static_cast<size_t>(count-9));
            keyString+= "+"+QString::fromStdString(label);
        }
        return keyString;
    }
}

QKeySequence UIRStatsMain::getKeyLaunchSequence(int count, QString & keyString) const
{
    keyString = getKeyAssignment(count);
    return QKeySequence(keyString);
}

QKeySequence UIRStatsMain::getKeyEditSequence(int count, QString & keyString) const
{
    keyString = getKeyAssignment(count)+"+F1";
    return QKeySequence(keyString);
}

QKeySequence UIRStatsMain::getKeyRemoveSequence(int count, QString & keyString) const
{
    keyString = getKeyAssignment(count)+"+Del";
    return QKeySequence(keyString);
}

void UIRStatsMain::clearButtonMaps()
{
    //Delete launch button maps
    for (const auto& it : m_launchButtonMap.toStdMap())
    {
        if (m_launchButtonMap[it.first] != nullptr)
        {
            delete m_launchButtonMap[it.first];
            m_launchButtonMap[it.first] = nullptr;
        }
    }

    for (const auto& it : m_editButtonMap.toStdMap())
    {
        if (m_editButtonMap[it.first] != nullptr)
        {
            delete m_editButtonMap[it.first];
            m_editButtonMap[it.first] = nullptr;
        }
    }

    for (const auto& it : m_removeButtonMap.toStdMap())
    {
        if (m_removeButtonMap[it.first] != nullptr)
        {
            delete m_removeButtonMap[it.first];
            m_removeButtonMap[it.first] = nullptr;
        }
    }
}

void UIRStatsMain::showEvent(QShowEvent *)
{
    for(QToolButton * button : m_allLaunchButtons)
    {
        if (button->property("isDisabled").toBool())
        {
            button->setDisabled(true);
        }
        if (button->property("isHidden").toBool())
        {
            button->setHidden(true);
        }
    }   
}

void UIRStatsMain::resizeEvent(QResizeEvent *)
{    
}

void UIRStatsMain::onExit()
{
    this->close();
}

void UIRStatsMain::onLaunchSettingsManager()
{
    UIRStatsSettingsManager().exec();
}

void UIRStatsMain::onLaunchAbout()
{
    UIRStatsAbout().exec();
}

void UIRStatsMain::onLaunchHelp()
{
    UIRStatsUtils::launchHelp("rstats_user_guide.pdf");
}

void UIRStatsMain::onAddNewModule()
{
    try
    {
        utils::RStatsModuleProperties props;
        std::string path = FileUtils::buildFilePath(RStatsUtils::getModulePropertiesPath(),"module_"+DateTimeUtils::getTimeStamp()+".xml");
        props.setDefinitionPath(path);
        QListWidgetItem * item = m_ui->m_lstModuleCategories->currentItem();
        if (item)
        {
            props.setCategory(item->text().toStdString());
        }
        UIRStatsLaunchConfigDialog(props).exec();
        this->onInitialize(m_ui->m_lstModuleCategories->currentIndex().row());
    }
    catch(std::exception& e)
    {
        UIRStatsErrorMessage("Could not add new module.",std::string(e.what()),false,this).exec();
    }
}

void UIRStatsMain::onLaunchModuleShortcut(QShortcut *button)
{
    launchModule(button->property("path").toString());
}

void UIRStatsMain::onUpdateTableHeader(bool isModuleListSelected)
{
}

void UIRStatsMain::onEditModuleShortcut(QShortcut *button)
{
    editModule(button->property("path").toString());
}

void UIRStatsMain::onRemoveModuleShortcut(QShortcut *button)
{
    removeModule(button->property("path").toString());
}

void UIRStatsMain::onLaunchModule(QAbstractButton *button)
{    
    launchModule(button->property("path").toString());
}

void UIRStatsMain::onEditModule(QAbstractButton *button)
{
    editModule(button->property("path").toString());
}

void UIRStatsMain::onRemoveModule(QAbstractButton *button)
{
    removeModule(button->property("path").toString());
}

void UIRStatsMain::editModule(const QString &propsPath)
{
    try
    {
        std::string path = propsPath.toStdString();
        utils::RStatsModuleProperties props;
        props.loadConfig(path);
        if (UIRStatsLaunchConfigDialog(props).launch())
        {
            onInitialize(m_ui->m_lstModuleCategories->currentIndex().row());
            if (m_currentTable && m_currentTable->count() > 0)
            {
                m_currentTable->setCurrentRow(0);
                m_currentTable->setFocus();
                m_tableHasFocus = true;
            }
        }
    }
    catch(std::exception& e)
    {
        UIRStatsErrorMessage("Could not edit module",std::string(e.what()),false,this).exec();
    }
}

void UIRStatsMain::removeModule(const QString &propsPath)
{
    try
    {
        std::string path = propsPath.toStdString();
        utils::RStatsModuleProperties props;
        props.loadConfig(path);
        int answer = QMessageBox::question(this,"Remove Module...", "Are you sure you want to remove the module \""+QString::fromStdString(props.getName())+"\"",QMessageBox::Yes,QMessageBox::No);
        if (answer == QMessageBox::Yes)
        {
            props.removeConfig();
            onInitialize(m_ui->m_lstModuleCategories->currentIndex().row());
            if (m_currentTable && m_currentTable->count() > 0)
            {
                m_currentTable->setCurrentRow(0);
                m_currentTable->setFocus();
                m_tableHasFocus = true;
            }
        }
    }
    catch(std::exception& e)
    {
        UIRStatsErrorMessage("Could not remove module",std::string(e.what()),false,this).exec();
    }
}

void UIRStatsMain::launchModule(const QString &propsPath)
{    
    try
    {
        RStatsModuleProperties props;
        props.loadConfig(propsPath.toStdString());
        std::string command,args;
        props.generateApplicationCommand(command,args);
        StringUtils::trimmedInPlace(command);
        if (FileUtils::fileExists(props.getPath()))
        {
            if (!props.isConsoleShown())
            {
                QProcess::startDetached(QString::fromStdString(command + " " + args));
            }
            else
            {
                SystemUtils::executeInTerminal(command,args);
            }
        }

        else
        {
            command = FileUtils::fileExists(FileUtils::buildFilePath(SystemUtils::getCurrentExecutableDirectory(),command));
            if (FileUtils::fileExists(command))
            {
                QProcess::startDetached(QString::fromStdString(command + " " + args));
            }
            else THROW_GENERIC_EXCEPTION("Could not find module at \""+props.getPath()+"\"");
        }
    }
    catch(std::exception& e)
    {
        UIRStatsErrorMessage("Could not launch module",std::string(e.what()),false,this).exec();
    }
}

void UIRStatsMain::onCategoryChanged(int row)
{
    QListWidgetItem * item = m_ui->m_lstModuleCategories->item(row);
    if (item)
    {
        onRepopulateModules(m_groupedModules[item->text().toStdString()]);
    }
}

void UIRStatsMain::onRepopulateModules(const std::vector<RStatsModuleProperties>& propsIn)
{
    //Current row
    int row = 0;

    m_ui->m_lstModules->clear();
    for(auto props : propsIn)
    {        
        QListWidgetItem * moduleChild = new QListWidgetItem;
        std::string properPath = StringUtils::replace(props.getPath(),"\\","/");
        bool hasPathSeperator = StringUtils::contains(properPath,"/");
        bool isDisabled = !hasPathSeperator || !FileUtils::fileExists(props.getPath());

        //On windows make sure we append .exe to binary before checking if it exists
        #ifdef __WIN32
            if (isDisabled && !StringUtils::endsWith(props.getPath(),".exe",false))
            {
                isDisabled = !hasPathSeperator || !FileUtils::fileExists(props.getPath()+".exe") || !FileUtils::fileExists(props.getPath()+".EXE");
            }
            else if (isDisabled)
            {
                isDisabled = !hasPathSeperator || !FileUtils::fileExists(props.getPath()) || !FileUtils::fileExists(props.getPath());
            }
        #endif


        if (isDisabled)
        {
            #ifdef __WIN32
                std::string propsPath1 = FileUtils::buildFilePath(SystemUtils::getCurrentExecutableDirectory(),props.getPath()+".exe");
                std::string propsPath2 = FileUtils::buildFilePath(SystemUtils::getCurrentExecutableDirectory(),props.getPath()+".EXE");
                std::string propsPath3 = FileUtils::buildFilePath(SystemUtils::getCurrentExecutableDirectory(),props.getPath());
                if (FileUtils::fileExists(propsPath1))
                {
                    props.setPath(propsPath1);
                    isDisabled = false;
                    props.saveConfig();
                }
                else if (FileUtils::fileExists(propsPath2))
                {
                    props.setPath(propsPath2);
                    isDisabled = false;
                    props.saveConfig();
                }
                else if (FileUtils::fileExists(propsPath3))
                {
                    props.setPath(propsPath3);
                    isDisabled = false;
                    props.saveConfig();
                }
            #else
                std::string propsPath = FileUtils::buildFilePath(SystemUtils::getCurrentExecutableDirectory(),props.getPath());
                if (FileUtils::fileExists(propsPath))
                {
                    props.setPath(propsPath);
                    isDisabled = false;
                    props.saveConfig();
                }
            #endif

        }

        QString path = QString::fromStdString(props.getDefinitionPath());

        //Setup shortcut key for module and edit/remove/launch buttons
        QString removeKeyString,editKeyString,launchKeyString;
        QKeySequence editKey = this->getKeyEditSequence(row, editKeyString);
        QKeySequence removeKey = this->getKeyRemoveSequence(row, removeKeyString);
        QKeySequence launchKey = this->getKeyLaunchSequence(row, launchKeyString);

        UIRStatsShortcut * editShortcut = new UIRStatsShortcut(editKey,m_ui->m_lstModuleCategories);
        UIRStatsShortcut * removeShortcut = new UIRStatsShortcut(removeKey,m_ui->m_lstModuleCategories);
        UIRStatsShortcut * launchShortcut = new UIRStatsShortcut(launchKey,m_ui->m_lstModuleCategories);

        editShortcut->setProperty("index",row);
        removeShortcut->setProperty("index",row);
        launchShortcut->setProperty("index",row);
        editShortcut->setProperty("path",path);
        removeShortcut->setProperty("path",path);
        launchShortcut->setProperty("path",path);
        moduleChild->setText(QString::fromStdString(props.getName()));
//        moduleChild->setText(1,launchKeyString);
//        moduleChild->setText(2,editKeyString);
//        moduleChild->setText(3,removeKeyString);
        if (isDisabled)
        {
            moduleChild->setIcon(m_iconError);
        }
        else
        {
            moduleChild->setIcon(UIRStatsUtils::getIcon(props.getIcon()));
        }
        m_ui->m_lstModules->addItem(moduleChild);


        //Connect signal to slots for editing, removing and launching a module via shortcut
        connect(editShortcut,SIGNAL(activated(QShortcut*)),this,SLOT(onEditModuleShortcut(QShortcut*)));
        connect(removeShortcut,SIGNAL(activated(QShortcut*)),this,SLOT(onRemoveModuleShortcut(QShortcut*)));
        connect(launchShortcut,SIGNAL(activated(QShortcut*)),this,SLOT(onLaunchModuleShortcut(QShortcut*)));
        ++row;
    }

}

void UIRStatsMain::keyPressEvent(QKeyEvent *event)
{
    if (m_currentTable == nullptr)
    {
        return;
    }

    if (event->key() == Qt::Key_Left || event->key() == Qt::Key_Right)
    {
        if (m_tableHasFocus)
        {
            m_tableHasFocus = false;
            m_ui->m_lstModuleCategories->setFocus();
            onUpdateTableHeader(m_tableHasFocus);
        }
        else
        {
            m_tableHasFocus = true;
            m_currentTable->setFocus();
            onUpdateTableHeader(m_tableHasFocus);
        }
    }
    else if (m_tableHasFocus && m_currentTable->currentRow() > -1)
    {
//        int rowIndex = m_currentTable->currentRow();
//        size_t tableIndex = m_currentTable->property("index").toUInt();
//        QButtonGroup * launchButtonGroup = m_launchButtonMap[tableIndex];
//        QButtonGroup * editButtonGroup = m_editButtonMap[tableIndex];
//        QButtonGroup * removeButtonGroup = m_removeButtonMap[tableIndex];
//        if (event->key() == Qt::Key_Enter || event->key() == Qt::Key_Return)
//        {
//            if (launchButtonGroup)
//            {
//                QAbstractButton * button = launchButtonGroup->button(rowIndex);
//                if (button)
//                {
//                    onLaunchModule(button);
//                }
//            }
//        }

//        if (event->key() == Qt::Key_F1)
//        {
//            if (editButtonGroup)
//            {
//                QAbstractButton * button = editButtonGroup->button(rowIndex);
//                if (button)
//                {
//                    onEditModule(button);
//                }
//            }
//        }
//        else if (event->key() == Qt::Key_Delete || event->key() == Qt::Key_Backspace)
//        {
//            if (removeButtonGroup)
//            {
//                QAbstractButton * button = removeButtonGroup->button(rowIndex);
//                if (button)
//                {
//                    onRemoveModule(button);
//                }
//            }
//        }
    }
}
}}}//end namespace

