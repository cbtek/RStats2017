/*
    UIRStatsMain.cpp
    

*/
//UIRStatsMain.cpp generated by CBTek Solutions on 02-03-2017 at 12:29:37 AM

#include <QDebug>
#include <QIcon>
#include <QGroupBox>
#include <QPushButton>
#include <QScrollArea>
#include <QFontMetrics>
#include <QLabel>
#include <QProcess>
#include <QMessageBox>
#include <QKeySequence>
#include <QTableWidgetItem>
#include <QPainter>

#include "UIRStatsMain.h"
#include "ui_UIRStatsMain.h"

#include "utility/inc/XMLReader.h"
#include "utility/inc/FileUtils.hpp"
#include "utility/inc/SystemUtils.hpp"


#include "rstats_utils/inc/RStatsSettingsManager.h"
#include "rstats_utils/inc/RStatsModuleProperties.h"
#include "rstats_utils/inc/RStatsUtils.hpp"
#include "rstats_utils/inc/RStatsWorkbook.h"

#include "rstats_ui/inc/UIRStatsAbout.h"
#include "rstats_ui/inc/UIRStatsErrorMessage.h"
#include "rstats_ui/inc/UIRStatsLaunchConfigDialog.h"
#include "rstats_ui/inc/UIRStatsSettingsManager.h"
#include "rstats_ui/inc/UIRStatsUtils.hpp"


using namespace cbtek::common::utility;

using namespace oig::ratstats::ui;
using namespace oig::ratstats::utils;

namespace oig {
namespace ratstats {
namespace main {

UIRStatsMain::UIRStatsMain(QWidget *parent) :
    QMainWindow(parent),
    m_ui(new Ui_UIRStatsMain)
{    
    m_ui->setupUi(this);              

    //Set UI Font
    this->setFont(QFont("arial",12));

    //Remove title bar widget from category dock
    m_ui->m_dockCategories->setTitleBarWidget(new QWidget());

    //Set images for all icons
    m_iconFolder = UIRStatsUtils::getIcon("img_folder.png");
    m_iconModule = UIRStatsUtils::getIcon("img_module.png");
    m_iconEdit = UIRStatsUtils::getIcon("img_edit.png");
    m_iconHelp = UIRStatsUtils::getIcon("img_help.png");
    m_iconAdd = UIRStatsUtils::getIcon("img_add.png");
    m_iconExit = UIRStatsUtils::getIcon("img_exit.png");
    m_iconSettings = UIRStatsUtils::getIcon("img_settings.png");
    m_iconAbout = UIRStatsUtils::getIcon("img_about.png");
    m_iconRemove = UIRStatsUtils::getIcon("img_remove.png");

    //Set icons to actions/buttons
    m_ui->m_actionExit->setIcon(m_iconExit);
    m_ui->m_actionAbout_RAT_STATS_2017->setIcon(m_iconAbout);
    m_ui->m_actionHelp_Topics->setIcon(m_iconHelp);
    m_ui->m_actionAdd_New_Module->setIcon(m_iconAdd);
    m_ui->m_actionSettings_Manager->setIcon(m_iconSettings);

    //Set default values
    m_buttonHeight = 40;
    m_currentTable = nullptr;
    m_tableHasFocus = false;
    m_ui->m_lstCategories->setStyleSheet("QListWidget:item{height:"+QString::number(m_buttonHeight+8)+"px;padding:1px;}");
    onInitialize(0);

    //Create SIGNAL/SLOT connections for all actions/buttons and other widgets
    connect(m_ui->m_actionExit,SIGNAL(triggered(bool)),this,SLOT(onExit()));
    connect(m_ui->m_actionSettings_Manager,SIGNAL(triggered(bool)),this,SLOT(onLaunchSettingsManager()));
    connect(m_ui->m_actionAbout_RAT_STATS_2017,SIGNAL(triggered(bool)),this,SLOT(onLaunchAbout()));
    connect(m_ui->m_actionAdd_New_Module,SIGNAL(triggered(bool)),this,SLOT(onAddNewModule()));
    connect(m_ui->m_lstCategories,SIGNAL(currentRowChanged(int)),this,SLOT(onTabChanged(int)));

}

UIRStatsMain::~UIRStatsMain()
{
    delete m_ui;
}

void UIRStatsMain::onInitialize(int defaultCategoryIndex)
{
    //Clear all launch buttons
    m_allLaunchButtons.clear();

    //Delete launch button maps
    for (const auto& it : m_launchButtonMap.toStdMap())
    {
        delete m_launchButtonMap[it.first];
    }

    for (const auto& it : m_editButtonMap.toStdMap())
    {
        delete m_editButtonMap[it.first];
    }

    for (const auto& it : m_removeButtonMap.toStdMap())
    {
        delete m_removeButtonMap[it.first];
    }

    //Clear modules
    m_ui->m_lstCategories->clear();

    //Create new layout
    QVBoxLayout * mainLayout = dynamic_cast<QVBoxLayout*>(m_ui->m_lytModules->layout());
    for (const auto & it : m_tableMap.toStdMap())
    {
        mainLayout->removeWidget(it.second);
        delete it.second;
    }
    m_tableMap.clear();

    //Grab the modules
    std::vector<RStatsModuleProperties> propsList;
    try
    {
         propsList = RStatsUtils::getModulePropertiesList();
    }
    catch (...)
    {
        RStatsUtils::createValidPath("config/.rstats_module_properties");
        RStatsUtils::createValidPath("config/.rstats_script_provider_properties");
        UIRStatsErrorMessage("No Modules Detected", "You have no modules available to launch.  You may create modules by pressing [Alt + N] or by clicking the \"Create new Module\" link in the file menu").exec();
        return;
    }

    //Loop over modules and determine which groups they belong to
    std::map<std::string, std::vector<RStatsModuleProperties> > groupedModules;
    for(const RStatsModuleProperties& props : propsList)
    {
        std::string category = props.getCategory();
        if (StringUtils::trimmed(category).size()==0)
        {
            category = "Uncategorized";
        }        
        groupedModules[category].push_back(props);
    }

    //Lets loop over all modules by group and populate the module tables
    size_t tableIndex = 0;    
    for (const auto& it : groupedModules)
    {
        QString name = QString::fromStdString(it.first);        
        QTableWidget * table = new QTableWidget;
        m_launchButtonMap[tableIndex] = new QButtonGroup;
        m_editButtonMap[tableIndex] = new QButtonGroup;
        m_removeButtonMap[tableIndex] = new QButtonGroup;
        QButtonGroup * launchButtons = m_launchButtonMap[tableIndex];
        QButtonGroup * editButtons = m_editButtonMap[tableIndex];
        QButtonGroup * removeButtons = m_removeButtonMap[tableIndex];

        int row = 0;
        int activeRow = 0;
        table->setRowCount(static_cast<int>(it.second.size()));
        table->setColumnCount(1);
        table->horizontalHeader()->hide();
        table->setSelectionMode(QAbstractItemView::SingleSelection);
        table->setSelectionBehavior(QTableView::SelectRows);
        table->setShowGrid(false);
        table->setAlternatingRowColors(true);
        table->setProperty("index",static_cast<unsigned int>(tableIndex));
        for(size_t a2 = 0 ;a2 < it.second.size();++a2)
        {
            RStatsModuleProperties props = it.second[a2];           
            QHBoxLayout * layout = new QHBoxLayout;
            QFrame * frame = new QFrame;
            layout->setProperty("index",QVariant::fromValue<size_t>(tableIndex));
            layout->setProperty("name",name);                        
            std::string properPath = StringUtils::replace(props.getPath(),"\\","/");
            bool hasPathSeperator = StringUtils::contains(properPath,"/");
            bool isDisabled = !hasPathSeperator || !FileUtils::fileExists(props.getPath());            
            #ifdef __WIN32
                if (isDisabled)
                {
                    isDisabled = !hasPathSeperator || !FileUtils::fileExists(props.getPath()+".exe") || !FileUtils::fileExists(props.getPath()+".EXE");
                }
            #endif

            //if module is disabled check to see if its in executable path
            if (isDisabled)
            {
                #ifdef __WIN32
                    std::string propsPath = FileUtils::buildFilePath(SystemUtils::getCurrentExecutableDirectory(),props.getPath()+".exe");
                #else
                    std::string propsPath = FileUtils::buildFilePath(SystemUtils::getCurrentExecutableDirectory(),props.getPath());
                #endif
                if (FileUtils::fileExists(propsPath))
                {
                    props.setPath(propsPath);
                    isDisabled = false;
                    props.saveConfig();
                }
            }

            QString path = QString::fromStdString(props.getDefinitionPath());

            //Setup edit button
            QPushButton * moduleEditButton = new QPushButton;            
            moduleEditButton->setProperty("path",path);
            UIRStatsUtils::setButtonStyle(moduleEditButton,this->font(),m_iconEdit,m_buttonHeight,true);
            moduleEditButton->setProperty("index",m_allLaunchButtons.size());
            editButtons->addButton(moduleEditButton,row);

            //Setup remove button
            QPushButton * moduleRemoveButton = new QPushButton;
            //moduleRemoveButton->setDisabled(isDisabled);
            moduleRemoveButton->setProperty("path",path);
            UIRStatsUtils::setButtonStyle(moduleRemoveButton,this->font(),m_iconRemove,m_buttonHeight,true);
            moduleRemoveButton->setProperty("index",m_allLaunchButtons.size());
            removeButtons->addButton(moduleRemoveButton,row);

            //Setup launch button
            QToolButton * moduleLaunchButton = new QToolButton;
            moduleLaunchButton->setProperty("path",path);
            moduleLaunchButton->setToolButtonStyle(Qt::ToolButtonTextBesideIcon);
            moduleLaunchButton->setText(QString::fromStdString(props.getName()));
            moduleLaunchButton->setProperty("index",m_allLaunchButtons.size());
            moduleLaunchButton->setIconSize(QSize(m_buttonHeight-8,m_buttonHeight-8));
            moduleLaunchButton->setIcon(UIRStatsUtils::getIcon(props.getIcon()));
            moduleLaunchButton->setDisabled(isDisabled);
            moduleLaunchButton->setMinimumHeight(m_buttonHeight);            
            moduleLaunchButton->setSizePolicy(QSizePolicy::Expanding,QSizePolicy::Expanding);
            m_allLaunchButtons.push_back(moduleLaunchButton);
            launchButtons->addButton(moduleLaunchButton,row);
            layout->setContentsMargins(4,4,4,4);
            layout->addWidget(moduleLaunchButton);
            layout->addWidget(moduleEditButton);
            layout->addWidget(moduleRemoveButton);
            frame->resize(frame->width(),m_buttonHeight);
            frame->setLayout(layout);
            table->setCellWidget(row,0,frame);
            table->setRowHeight(row,m_buttonHeight+8);

            //Setup shortcut key for module and edit/remove/launch buttons
            QString removeKeyString,editKeyString,launchKeyString;
            QKeySequence editKey = this->getKeyEditSequence(row, editKeyString);
            QKeySequence removeKey = this->getKeyRemoveSequence(row, removeKeyString);
            QKeySequence launchKey = this->getKeyLaunchSequence(row, launchKeyString);
            QTableWidgetItem * verticalItem = new QTableWidgetItem;            
            verticalItem->setText(launchKeyString);
            verticalItem->setData(Qt::UserRole,activeRow);


            if (isDisabled)
            {
                verticalItem->setBackground(QBrush(QColor(255,255,255)));
                verticalItem->setForeground(QBrush(QColor(127,127,127)));
                verticalItem->setTextColor(QColor(127,127,127));
                verticalItem->setFont(QFont("arial",10,-1,true));
            }
            else
            {
                verticalItem->setBackground(QBrush(QColor(127,255,127)));
                verticalItem->setForeground(QBrush(QColor(0,0,0)));
                verticalItem->setTextColor(QColor(0,0,0));
                verticalItem->setFont(QFont("arial",12,8,false));
            }

            table->setVerticalHeaderItem(row,verticalItem);                    
            UIRStatsShortcut * editShortcut = new UIRStatsShortcut(editKey,table);
            UIRStatsShortcut * removeShortcut = new UIRStatsShortcut(removeKey,table);
            UIRStatsShortcut * launchShortcut = new UIRStatsShortcut(launchKey,table);            
            editShortcut->setProperty("index",row);
            removeShortcut->setProperty("index",row);
            launchShortcut->setProperty("index",row);
            editShortcut->setProperty("path",path);
            removeShortcut->setProperty("path",path);
            launchShortcut->setProperty("path",path);

            //Connect signal to slots for editing, removing and launching a module via shortcut
            connect(editShortcut,SIGNAL(activated(QShortcut*)),this,SLOT(onEditModuleShortcut(QShortcut*)));
            connect(removeShortcut,SIGNAL(activated(QShortcut*)),this,SLOT(onRemoveModuleShortcut(QShortcut*)));
            connect(launchShortcut,SIGNAL(activated(QShortcut*)),this,SLOT(onLaunchModuleShortcut(QShortcut*)));            
            ++row;
        }

        //Set first row as default row
        if (table->rowCount() > 0)
        {
            table->selectRow(0);
        }

        //set table properties and add current group name to category list
        table->horizontalHeader()->setSectionResizeMode(0,QHeaderView::Stretch);
        m_tableMap[tableIndex] = table;
        mainLayout->addWidget(table);
        m_ui->m_lstCategories->addItem(new QListWidgetItem(m_iconFolder,name));
        ++tableIndex;
        connect(launchButtons,SIGNAL(buttonClicked(QAbstractButton*)),this,SLOT(onLaunchModule(QAbstractButton*)));
        connect(editButtons,SIGNAL(buttonClicked(QAbstractButton*)),this,SLOT(onEditModule(QAbstractButton*)));
        connect(removeButtons,SIGNAL(buttonClicked(QAbstractButton*)),this,SLOT(onRemoveModule(QAbstractButton*)));
    }      

    //Set the default category index if this function was called from an remove/update/new call
    if (defaultCategoryIndex < m_ui->m_lstCategories->count())
    {
        onTabChanged(defaultCategoryIndex);
        m_ui->m_lstCategories->setCurrentRow(defaultCategoryIndex);
    }   
}


QString UIRStatsMain::getKeyAssignment(int count) const
{

    //set up unique shortcut key for up to 180 modules per group
    QString keyString;
    if (count < 36)
    {
        keyString = "Shift+Ctrl";
    }
    else if (count >= 36 && count < 72)
    {
        count-=36;
        keyString = "Shift+Alt";
    }

    else if (count >= 72 && count < 108)
    {
        count-=72;
        keyString = "Alt+Ctrl";
    }

    else if (count >= 108 && count < 144)
    {
        count-=108;
        keyString = "Ctrl+Shift";

    }
    else if (count >= 144 && count < 180)
    {
        count-=144;
        keyString = "Alt+Shift";
    }

    if (count < 9)
    {
         keyString+= "+"+QString::fromStdString(std::to_string((count+1)));
    }
    else
    {
        std::string label = RStatsUtils::getColumnLabelFromIndex(static_cast<size_t>(count-9));
        keyString+= "+"+QString::fromStdString(label);
    }
    return keyString;
}

QKeySequence UIRStatsMain::getKeyLaunchSequence(int count, QString & keyString) const
{
    keyString = getKeyAssignment(count);
    return QKeySequence(keyString);
}

QKeySequence UIRStatsMain::getKeyEditSequence(int count, QString & keyString) const
{
    keyString = getKeyAssignment(count)+"+E";
    return QKeySequence(keyString);
}

QKeySequence UIRStatsMain::getKeyRemoveSequence(int count, QString & keyString) const
{
    keyString = getKeyAssignment(count)+"+R";
    return QKeySequence(keyString);
}

void UIRStatsMain::showEvent(QShowEvent *)
{
    for(QToolButton * button : m_allLaunchButtons)
    {
        if (button->property("isDisabled").toBool())
        {
            button->setDisabled(true);
        }
        if (button->property("isHidden").toBool())
        {
            button->setHidden(true);
        }
    }

    if(m_ui->m_lstCategories->count() > 0)
    {
        onTabChanged(0);
    }
}

void UIRStatsMain::resizeEvent(QResizeEvent *)
{    
}

void UIRStatsMain::onExit()
{
    this->close();
}

void UIRStatsMain::onLaunchSettingsManager()
{
    UIRStatsSettingsManager().exec();
}

void UIRStatsMain::onLaunchAbout()
{
    UIRStatsAbout().exec();
}

void UIRStatsMain::onLaunchHelp()
{

}

void UIRStatsMain::onTabChanged(int tab)
{
    if (tab < 0)return;
    size_t index = static_cast<size_t>(tab);
    for (const auto & it : m_tableMap.toStdMap())
    {
        it.second->hide();
        m_currentTable = nullptr;
    }
    if (m_tableMap.contains(index))
    {
        m_tableMap[index]->show();
        m_currentTable = m_tableMap[index];
    }
}

void UIRStatsMain::onAddNewModule()
{
    utils::RStatsModuleProperties props;
    QListWidgetItem * item = m_ui->m_lstCategories->currentItem();
    if (item)
    {
        props.setCategory(item->text().toStdString());
    }
    UIRStatsLaunchConfigDialog(props).exec();
    this->onInitialize(m_ui->m_lstCategories->currentRow());
}

void UIRStatsMain::onLaunchModuleShortcut(QShortcut *button)
{
    launchModule(button->property("path").toString());
}

void UIRStatsMain::onEditModuleShortcut(QShortcut *button)
{
    editModule(button->property("path").toString());
}

void UIRStatsMain::onRemoveModuleShortcut(QShortcut *button)
{
    removeModule(button->property("path").toString());
}

void UIRStatsMain::onLaunchModule(QAbstractButton *button)
{
   launchModule(button->property("path").toString());
}

void UIRStatsMain::onEditModule(QAbstractButton *button)
{
    editModule(button->property("path").toString());
}

void UIRStatsMain::onRemoveModule(QAbstractButton *button)
{
    removeModule(button->property("path").toString());
}

void UIRStatsMain::editModule(const QString &propsPath)
{
    try
    {
        std::string path = propsPath.toStdString();
        utils::RStatsModuleProperties props;
        props.loadConfig(path);
        if (UIRStatsLaunchConfigDialog(props).launch())
        {
            onInitialize(m_ui->m_lstCategories->currentRow());
            if (m_currentTable && m_currentTable->rowCount() > 0)
            {
                m_currentTable->selectRow(0);
                m_currentTable->setFocus();
                m_tableHasFocus = true;
            }
        }
    }
    catch(std::exception& e)
    {
        QMessageBox::critical(this,"Module Edit Error",QString(e.what()));
    }
}

void UIRStatsMain::removeModule(const QString &propsPath)
{
    try
    {
        std::string path = propsPath.toStdString();
        utils::RStatsModuleProperties props;
        props.loadConfig(path);
        int answer = QMessageBox::question(this,"Remove Module...", "Are you sure you want to remove the module \""+QString::fromStdString(props.getName())+"\"",QMessageBox::Yes,QMessageBox::No);
        if (answer == QMessageBox::Yes)
        {
            props.removeConfig();
            onInitialize(m_ui->m_lstCategories->currentRow());
            if (m_currentTable && m_currentTable->rowCount() > 0)
            {
                m_currentTable->selectRow(0);
                m_currentTable->setFocus();
                m_tableHasFocus = true;
            }
        }
    }
    catch(std::exception& e)
    {
        QMessageBox::critical(this,"Module Edit Error",QString(e.what()));
    }
}

void UIRStatsMain::launchModule(const QString &propsPath)
{
    std::string launcherPath = FileUtils::buildFilePath(SystemUtils::getCurrentExecutableDirectory(),"rstats_launcher");
    if (m_currentTable)
    {
        m_currentTable->setFocus();
        m_tableHasFocus = true;
    }

    if (!FileUtils::fileExists(launcherPath))
    {
        QMessageBox::critical(this,"Module Launch Error", "Can not launch this module.  Ensure that the module launcher (rstats_launcher) is installed.");
        return;
    }

    QString command = QString::fromStdString(launcherPath)+" --module-path \""+propsPath+"\"";        
    QProcess::startDetached(command);
}

void UIRStatsMain::paintEvent(QPaintEvent *event)
{

}

void UIRStatsMain::keyPressEvent(QKeyEvent *event)
{
    if (m_currentTable == nullptr)
    {
        return;
    }

    if (event->key() == Qt::Key_Left || event->key() == Qt::Key_Right)
    {
        if (m_tableHasFocus)
        {
            m_tableHasFocus = false;
            m_ui->m_lstCategories->setFocus();
        }
        else
        {
            m_tableHasFocus = true;
            m_currentTable->setFocus();
        }
    }
    else if (m_tableHasFocus && m_currentTable->currentRow() > -1)
    {
        int rowIndex = m_currentTable->currentRow();
        size_t tableIndex = m_currentTable->property("index").toUInt();
        QButtonGroup * launchButtonGroup = m_launchButtonMap[tableIndex];
        QButtonGroup * editButtonGroup = m_editButtonMap[tableIndex];
        QButtonGroup * removeButtonGroup = m_removeButtonMap[tableIndex];
        if (event->key() == Qt::Key_Enter || event->key() == Qt::Key_Return)
        {
            if (launchButtonGroup)
            {
                QAbstractButton * button = launchButtonGroup->button(rowIndex);
                if (button)
                {
                    onLaunchModule(button);
                }
            }
        }

        if (event->key() == Qt::Key_F1)
        {
            if (editButtonGroup)
            {
                QAbstractButton * button = editButtonGroup->button(rowIndex);
                if (button)
                {
                    onEditModule(button);
                }
            }
        }
        else if (event->key() == Qt::Key_Delete || event->key() == Qt::Key_Backspace)
        {
            if (removeButtonGroup)
            {
                QAbstractButton * button = removeButtonGroup->button(rowIndex);
                if (button)
                {
                    onRemoveModule(button);
                }
            }
        }
    }
}
}}}//end namespace

