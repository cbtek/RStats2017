/*
    RStatsCSVWorkbookStream.cpp
    

*/
//----------------------------------------
//RStatsCSVWorkbookStream.cpp generated by cbtek on 04-01-2017 at 06:35:19 PM
//----------------------------------------
#include "RStatsCSVWorkbookStream.h"

#include "utility/inc/StringUtils.hpp"

#include <stack>
using namespace cbtek::common::utility;

namespace oig {
namespace ratstats {
namespace utils {
namespace streams {

enum class RStatsCSVDataParseTypes
{
    Start,
    Empty,
    NotQuoted,
    Quoted
};

RStatsCSVWorkbookStream::RStatsCSVWorkbookStream(const std::string &filePath)
{
    m_filePaths.push_back(filePath);
}

RStatsCSVWorkbookStream::RStatsCSVWorkbookStream(const std::vector<std::string> &filePaths)
{
    m_filePaths = filePaths;
}

void RStatsCSVWorkbookStream::write(const RStatsWorkbook &workbook)
{
    const std::vector<RStatsWorksheet>& sheets = workbook.getWorksheets();
    const std::vector<std::string> sheetNames = workbook.getWorksheetNames();

    std::string rootFilePath;
    size_t count = 0;
    if (workbook.getNumWorksheets() > m_filePaths.size() && m_filePaths.size() > 0)
    {
        rootFilePath = m_filePaths[0];
        m_filePaths.clear();
        for(const auto& sheetName : sheetNames)
        {
            if (StringUtils::isEmpty(sheetName) )
            {
                m_filePaths.push_back(rootFilePath+"_sheet["+StringUtils::toString(count)+"].dif");
            }
            else
            {
                m_filePaths.push_back(rootFilePath+"_"+FileUtils::getSanitizedPathName(sheetName)+".dif");
            }
            ++count;
        }
    }

    count = 0;

    for (const RStatsWorksheet& sheetIn : sheets)
    {
        std::string filePath = m_filePaths[count];
        FileUtils::writeFileContents(filePath,sheetIn.toCommaDelimitedString());
        ++count;
    }
}

RStatsWorkbook RStatsCSVWorkbookStream::read()
{
    RStatsWorkbook workbook;
    for(const auto& filePath : m_filePaths)
    {
        std::ifstream in(filePath.c_str(), std::ios::in);
        size_t row = 0;
        RStatsWorksheet sheet;
        while (in)
        {
            std::string line;
            std::getline(in,line);
            StringUtils::trimmedInPlace(line);
            if (!in)
            {
                break;
            }

            readRow(line,sheet,row);
            ++row;
        }
        workbook.addWorksheet(sheet);
    }
    return workbook;
}

RStatsCSVWorkbookStream::~RStatsCSVWorkbookStream()
{

}

//x,y,z
//,,,
//1,2,3
//"1","2","3"
//"1",2,"3"
//"1,2 and 3", "4, 5 and 6", ""Hello", "World""
void RStatsCSVWorkbookStream::readRow(const std::string &line,
                                      RStatsWorksheet &sheetOut,
                                      size_t currentRow)
{
    size_t index = 0;
    size_t currentColumn = 0;
    while (readCell(line,index,sheetOut(currentRow,currentColumn).text))
    {
        ++currentColumn;
    }
}

bool RStatsCSVWorkbookStream::readCell(const std::string &line,
                                       size_t &startIndex,
                                       std::string &dataOut)
{
    RStatsCSVDataParseTypes type = RStatsCSVDataParseTypes::Start;
    size_t quoteCount = 0;

    //This boolean flag is used for helping know when
    //the data stream starts so that the ParseType
    //can be set.
    bool start = true;

    for (size_t a1 = startIndex; a1 < line.size(); ++a1)
    {
        char token = line[a1];
        if (start && token == '\"')
        {
            type = RStatsCSVDataParseTypes::Quoted;
            quoteCount++;
            start = false;
            continue;
        }
        else if(start)
        {
            type = RStatsCSVDataParseTypes::NotQuoted;
            start = false;
        }

        if (type == RStatsCSVDataParseTypes::Quoted)
        {
            //If we encounter a quote while in "Quoted" mode
            //then this must quote must be part of the cell
            //data.  Keep counting the number of quotes in
            //the cell data.  When a comma is reached if the
            //number of quotes counted is divisible by 2 then
            //the end of the cell data has been reached. Other
            //wise the comma is also part of the cell data.
            if (token == '\"')
            {
                quoteCount++;

                //Check for closing quote in cell data when
                //comma is discovered.  If this is the closing
                //quote then we can return false to go to the next
                //row in the file.  Also we have to convert the
                // [""]'s to ["]'s in the dataOut string
                if (a1 == line.size() - 1 && quoteCount % 2 == 0)
                {
                    startIndex = 0;
                    StringUtils::replaceInPlace(dataOut,"\"\"","\"");
                    return false;
                }
                dataOut.push_back(token);
            }

            else if (token == ',')
            {
                //Check for closing quote in cell data when
                //comma is discovere.  If this is the closing
                //quote then we can return true to continue
                //reading cells from this row
                if (quoteCount % 2 == 0)
                {
                    startIndex = a1 + 1;
                    parseLastCellOnRow(dataOut);
                    return true;
                }
                else
                {
                    dataOut.push_back(token);
                }
            }
            else
            {
                dataOut.push_back(token);
            }
        }
        else
        {
            //When comma is discovered for non-quoted data
            //then we can update the start index and continue
            //reading the next cell data on the row
            if (token == ',')
            {
                startIndex = a1 + 1;
                return true;
            }
            dataOut.push_back(token);
        }
    }

    //When end of line occurs before reading a comma
    //lets just return false and continue reading next
    //row from file.
    return false;

}

void RStatsCSVWorkbookStream::parseLastCellOnRow(std::string& dataOut)
{
    //So we had to add the last quote to the
    //dataOut field to read the comma seperator.
    //The code below removes that last quote.
    int dataOutSize = static_cast<int>(dataOut.size());
    for (int a2 = dataOutSize - 1; a2 >= 0; --a2)
    {
        size_t index = static_cast<size_t>(a2);
        if (dataOut[index] == ' ')
        {
            continue;
        }
        if (dataOut[index] == '\"')
        {
            dataOut.erase(dataOut.begin()+a2);
            StringUtils::replaceInPlace(dataOut,"\"\"","\"");
            return;
        }
    }
}




}}}}//end namespace


