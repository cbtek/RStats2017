/*
    RStatsWorksheet.cpp
    

*/
//----------------------------------------
//RStatsWorksheet.cpp generated by CBTek Solutions on 02-01-2017 at 06:31:40 PM
//----------------------------------------
#include "RStatsWorksheet.h"

#include "utility/inc/StringUtils.hpp"

#include "utility/inc/XMLUtils.h"

using namespace cbtek::common::utility;

namespace oig {
namespace ratstats {
namespace utils {

RStatsTextAlignment RStatsCell::ms_DefaultAlignment = RStatsTextAlignment::AlignLeft;
Color RStatsCell::ms_DefaultBGColor = ColorFactory::create(colors::TRANSPARENT_1);
Color RStatsCell::ms_DefaultFGColor = Color(0,0,0);
Font RStatsCell::ms_DefaultFont = cbtek::common::utility::Font("arial");
size_t RStatsCell::ms_DefaultFloatingPointDecimals = 6;



RStatsWorksheet::RStatsWorksheet(const std::string &name)
{
    m_numColumns = 0;
    m_numRows = 0;
    m_worksheetTitle = name;
}

RStatsCell& RStatsWorksheet::operator()(const std::string &address)
{
    size_t r = 0,c = 0;
    std::vector<std::string> parts = StringUtils::split(address,":");
    if (parts.size() == 1)
    {
        parseCellAddress(address,r,c);
    }
    else
    {
        size_t startR = 0,startC = 0,endR = 0,endC = 0;
        parseCellAddress(parts[0],startR,startC);
        parseCellAddress(parts[1],endR,endC);
        RStatsMergeCellRange range;
        range.startRow = startR;
        range.startColumn = startC;
        range.rowOffset = endR - startR;
        range.columnOffset = endC - startC;
        if (!m_mergedCellTable.count(range))
        {
            m_mergedCellTable[range] = m_dataTable[std::make_pair(startR,startC)];
            for (size_t r = startR; r <= endR; ++r )
                for (size_t c = startC; c <= endC; ++c )
                    m_dataTable.erase(std::make_pair(r,c));
        }
    }
    return this->operator ()(r,c);
}

size_t RStatsWorksheet::getNumRows() const
{
    return m_numRows;
}

size_t RStatsWorksheet::getNumColumns() const
{
    return m_numColumns;
}

std::pair<size_t,size_t> RStatsWorksheet::getLastDataRowAndColumn() const
{
    size_t rows = getNumRows();
    size_t cols = getNumColumns();
    if (rows == 0 || cols == 0)
    {
        return std::make_pair(0,0);
    }

    for (int r = rows-1; r >= 0;++r)
    {
        for (int c = cols-1; c >= 0;++c)
        {
            if (!StringUtils::isEmpty(getCell(r,c).text))
            {
                return std::make_pair(r,c);
            }
        }
    }
    return std::make_pair(0,0);
}

const RStatsCellMap &RStatsWorksheet::getCells() const
{
    return m_dataTable;
}

void RStatsWorksheet::setDefaultTextAlignment(RStatsTextAlignment alignment)
{
    RStatsCell::ms_DefaultAlignment = alignment;
}

void RStatsWorksheet::setDefaultBGColor(const Color &bgColor)
{
    RStatsCell::ms_DefaultBGColor = bgColor;
}

void RStatsWorksheet::setDefaultFGColor(const Color &fgColor)
{
    RStatsCell::ms_DefaultFGColor = fgColor;
}

void RStatsWorksheet::setDefaultFont(const Font &font)
{
    RStatsCell::ms_DefaultFont = font;
}

void RStatsWorksheet::setDefaultFloatingPointDecimals(size_t count)
{
    RStatsCell::ms_DefaultFloatingPointDecimals = count;
}

void RStatsWorksheet::resetDefaults()
{
    RStatsCell::ms_DefaultAlignment = RStatsTextAlignment::AlignLeft;
    RStatsCell::ms_DefaultBGColor = ColorFactory::create(colors::TRANSPARENT_1);
    RStatsCell::ms_DefaultFGColor = Color(0,0,0);
    RStatsCell::ms_DefaultFont = cbtek::common::utility::Font("arial");
    RStatsCell::ms_DefaultFloatingPointDecimals = 6;
}

std::string RStatsWorksheet::toCommaDelimitedString() const
{
    return toString("\"",",","\"");
}

std::string RStatsWorksheet::toTabDelimitedString() const
{
    return toString("","\t","");
}

std::string RStatsWorksheet::toHTMLTableString(bool includeRowLabels,
                                               bool includeColumnLabels) const
{
    std::ostringstream out;
    XMLStreamWriter xml(out);
    xml.writeStartElementNoAttributes("html");
    xml.writeStartElementNoAttributes("head");        
    xml.writeTextElement("title",m_worksheetTitle+" Output");
    xml.writeEndElement("head");
    xml.writeStartElementNoAttributes("body");
    xml.writeStartElement("table");
    xml.writeLastAttribute("style","border-collapse:collapse;border: 1px solid black; padding 5px;");

    size_t cols = getNumColumns();
    size_t rows = getNumRows();

    //Need to finish implementing adding row/column headers
    for(size_t r = 0;r<rows;++r)
    {
        if (includeColumnLabels && r == 0)
        {
            xml.writeStartElementNoAttributes("tr");
            xml.writeTextElement("td","");
            for(size_t c = 0;c<cols;++c)
            {
                xml.writeStartElement("td");
                xml.writeLastAttribute("style","background:#"+((c%2)? std::string("AAAAAA;"): std::string("DEDEDE;"))+"border:1px solid black;");
                xml.writeText(RStatsUtils::getColumnLabelFromIndex(c));
                xml.writeEndElement("td");
            }
            xml.writeEndElement("tr");
        }
        xml.writeStartElementNoAttributes("tr");
        for(size_t c = 0;c<cols;++c)
        {
            if (includeRowLabels && c == 0)
            {
                xml.writeStartElement("td");
                xml.writeLastAttribute("style","color:black;background:#"+((r%2)? std::string("AAAAAA;"): std::string("DEDEDE;"))+"border:1px solid black;");
                xml.writeText(StringUtils::toString(r+1));
                xml.writeEndElement("td");
            }
            const RStatsCell& cell = getCell(r,c);
            xml.writeStartElement("td");
            xml.writeLastAttribute("style",getCellCSSStyle(cell));
            if (StringUtils::isNumeric(cell.text))
            {
                xml.writeText(StringUtils::formatWithThousandsLabel(cell.text));
            }
            else
            {
                xml.writeText(cell.text);
            }
            xml.writeEndElement("td");
        }
        xml.writeEndElement("tr");
    }
    xml.writeEndElement("table");
    xml.writeEndElement("body");
    xml.writeEndElement("html");    
    return out.str();
}

std::string RStatsWorksheet::toEvenlySpacedString() const
{
    return toEvenlySpacedString("","","");
}

bool RStatsWorksheet::isEmpty() const
{
    return (this->m_dataTable.size() == 0);
}

void RStatsWorksheet::findDataRowsAndColumns(std::set<size_t> &rowsOut,
                                             std::set<size_t> &columnsOut) const
{
    size_t cols = getNumColumns();
    size_t rows = getNumRows();
    std::ostringstream out;
    for(size_t r = 0;r<rows;++r)
    {
        bool hasData = false;
        for(size_t c = 0;c<cols;++c)
        {
            std::string data = getCell(r,c).text;
            if (!StringUtils::isEmpty(data))
            {
                hasData = true;
                columnsOut.insert(c);
            }
        }

        if (hasData)
        {
            rowsOut.insert(r);
        }
    }
}

void RStatsWorksheet::setThousandsSeperatorEnabled(bool flag)
{
    RStatsWorksheet & sheet = (*this);
    if (flag)
    {

        for(size_t r = 0; r < sheet.getNumRows(); ++r)
        {
            for(size_t c = 0; c < sheet.getNumColumns(); ++c)
            {
                if (StringUtils::isNumeric(sheet(r,c).text) && sheet(r,c).text.size() > 3)
                {
                    m_thousandsSeperatorToggleSet.insert(std::make_pair(r,c));
                    sheet(r,c).text = StringUtils::formatWithThousandsLabel(sheet(r,c).text);
                }
            }
        }
    }
    else
    {
        for(const auto& pair : m_thousandsSeperatorToggleSet)
        {
            size_t r = pair.first;
            size_t c = pair.second;
            sheet(r,c).text = StringUtils::remove(sheet(r,c).text,",");
        }
        m_thousandsSeperatorToggleSet.clear();
    }
}

void RStatsWorksheet::clear()
{
    m_dataTable.clear();
    m_numColumns = m_numRows = 0;
    m_worksheetTitle = "";
}

RStatsCell& RStatsWorksheet::operator()(size_t row, size_t column)
{
    if (row >= m_numRows)
    {
        m_numRows = row + 1;
    }
    if (column >= m_numColumns)
    {
        m_numColumns = column + 1;
    }

    if (this->isCellInMergedCellRange(row,column))
    {
        return getCellInMergedCellRange(row,column);
    }
    else return m_dataTable[std::make_pair(row,column)];
}

const RStatsCell &RStatsWorksheet::operator()(size_t row, size_t column) const
{
    return getCell(row,column);
}

const RStatsCell &RStatsWorksheet::getCell(size_t row, size_t column) const
{    
    if (isCellInMergedCellRange(row,column))
    {
        for (const auto& it : m_mergedCellTable)
        {
            if (it.first.contains(row,column))
            {
                return it.second;
            }
        }
    }

    const auto& it = m_dataTable.find(std::make_pair(row,column));
    if (it != m_dataTable.end())
    {
        return it->second;
    }
    else if (row < getNumRows() && column < getNumColumns())
    {
        return m_emptyCell;
    }
    THROW_GENERIC_EXCEPTION("The row/column is out of range for this cell.\n"+
                            std::to_string(row)+" should be less than "+std::to_string(getNumRows())+
                            +"\n"+std::to_string(column)+" should be less than "+std::to_string(getNumColumns()));
}

RStatsWorksheet::~RStatsWorksheet()
{

}

void RStatsWorksheet::setRowBorderColor(size_t row, const Color &color)
{
    for (size_t a1 = 0; a1 < getNumColumns();++a1)
    {
        this->operator()(row,a1).bgColor = color;
    }
}

void RStatsWorksheet::setColumnBorderColor(size_t column, const Color &color)
{
    for (size_t a1 = 0; a1 < getNumRows();++a1)
    {
        this->operator()(a1,column).bgColor = color;
    }
}


void RStatsWorksheet::parseCellAddress(const std::string &address, size_t &r, size_t &c)
{
    std::string colLabel;
    std::string rowLabel;
    for (char i : address)
    {
        if (std::isalpha(i))
        {
            colLabel.push_back(i);
        }
        else if (std::isdigit(i))
        {
            rowLabel.push_back(i);
        }
    }
    long index = StringUtils::toInt(rowLabel) - 1;
    if (index < 0)
    {
        index = 0;
    }
    r = static_cast<size_t>(index);

    c = RStatsUtils::getColumnIndexFromLabel(colLabel);
}

std::string RStatsWorksheet::toString(const std::string &prefix,
                               const std::string &seperator,
                               const std::string &postfix) const
{
    size_t cols = getNumColumns();
    size_t rows = getNumRows();
    std::ostringstream out;
    for(size_t r = 0;r<rows;++r)
    {
        for(size_t c = 0;c<cols;++c)
        {
            RStatsCell cell = getCell(r,c);            
            std::string data = cell.text;
            StringUtils::replaceInPlace(data,"\"","\"\"");
            out << prefix << data << postfix << ((c<(cols-1))?seperator:"\n");
        }
    }
    return out.str();
}

std::string RStatsWorksheet::toEvenlySpacedString(const std::string &prefix,
                                                  const std::string &seperator,
                                                  const std::string &postfix) const
{
    size_t cols = getNumColumns();
    size_t rows = getNumRows();
    std::vector<size_t> columnWidths(cols);
    for(size_t r = 0;r<rows;++r)
    {
        for(size_t c = 0;c<cols;++c)
        {
            RStatsCell cell = getCell(r,c);            
            std::string data = cell.text;
            if (columnWidths[c] < data.size()+4)
            {
                columnWidths[c]=data.size()+4;
            }
        }
    }

    std::ostringstream out;
    for(size_t r = 0;r<rows;++r)
    {
        for(size_t c = 0;c<cols;++c)
        {
            RStatsCell cell = getCell(r,c);            
            std::string data = cell.text;
            std::string space;
            if (columnWidths[c] > data.size())
            {
                space = StringUtils::repeat(" ", (columnWidths[c] - data.size()));
            }
            out <<space << prefix << data << postfix << ((c<(cols-1))?seperator:"\n");
        }
    }
    return out.str();
}

bool RStatsWorksheet::isCellInMergedCellRange(size_t r, size_t c) const
{
    for (const auto& it : m_mergedCellTable)
    {
        if (it.first.contains(r,c))
        {
            return true;
        }
    }
    return false;
}

RStatsCell& RStatsWorksheet::getCellInMergedCellRange(size_t r, size_t c)
{
    for (auto& it : m_mergedCellTable)
    {
        if (it.first.contains(r,c))
        {
            return it.second;
        }
    }
    return m_emptyCell;
}


bool RStatsWorksheet::getMergedCellRangeThatContains(size_t r, size_t c, RStatsMergeCellRange &range)
{
    for (auto it : m_mergedCellTable)
    {
        if (it.first.contains(r,c))
        {
            range = it.first;
            return true;
        }
    }
    return false;
}

std::string RStatsWorksheet::getCellCSSStyle(const RStatsCell &cell) const
{
    std::string css;
    if (cell.bgColor != cell.fgColor)
    {
        css += "background: " + cell.bgColor.toString(ColorStringStyle::RGB_HTML_HEX) + ";";
        css += "color: " + cell.fgColor.toString(ColorStringStyle::RGB_HTML_HEX) + ";";
    }
    css += "border: 1px solid black;";
    css += "font-size: " + StringUtils::toString(cell.font.getPointSize()+2)+"px;";
    css += "font-weight: " + std::string(cell.font.isBold() ? "bold;" : "normal;");
    css += "font-family: " + cell.font.getFontFamily()+";";
    css += "font-style: " + std::string(cell.font.isItalic() ? "italic;" : "normal;");
    std::string halign,valign;
    valign = "vertical-align: middle;";
    if (cell.alignment == RStatsTextAlignment::AlignLeft)
    {
        halign = "text-align: left;";
    }
    else if (cell.alignment == RStatsTextAlignment::AlignRight)
    {
        halign = "text-align: right;";
    }
    else if (cell.alignment == RStatsTextAlignment::AlignMiddle)
    {
        halign = "text-align: center;";
    }
    css += halign;
    css += valign;
    return css;
}

void RStatsWorksheet::setWorksheetTitle(const std::string & value)
{
    m_worksheetTitle=value;
}

const std::string &RStatsWorksheet::getWorksheetTitle() const
{
    return m_worksheetTitle;
}

void RStatsWorksheet::setRowBackgroundColor(size_t row, const cbtek::common::utility::Color &color)
{
    for (size_t a1 = 0; a1 < getNumColumns();++a1)
    {
        this->operator()(row,a1).bgColor = color;
    }
}

void RStatsWorksheet::setColumnBackgroundColor(size_t column, const Color &color)
{
    for (size_t a1 = 0; a1 < getNumRows();++a1)
    {
        this->operator()(a1,column).bgColor = color;
    }
}

}}}//end namespace


