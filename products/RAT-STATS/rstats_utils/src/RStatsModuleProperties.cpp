/*
    RStatsModuleProperties.cpp
    

*/
//----------------------------------------
//RStatsModuleProperties.cpp generated by sunefusion on 02-28-2017 at 09:39:48 PM
//----------------------------------------
#include "RStatsModuleProperties.h"

#include <sstream>

#include "utility/inc/XMLReader.h"
#include "utility/inc/XMLStreamWriter.h"

using namespace cbtek::common::utility;

namespace oig {
namespace ratstats {
namespace utils {


RStatsModuleProperties::RStatsModuleProperties()
{
    m_showAppConsole = false;
}

RStatsModuleProperties::~RStatsModuleProperties()
{

}

void RStatsModuleProperties::loadApplicationConfig(const std::string &filePath)
{
    XMLReader reader;
    reader.load(filePath);
    XMLDataElement * module = reader.getElement("module");
    if (module)
    {
        m_appName = module->getAttributeValue("name");
        m_appPath = module->getAttributeValue("path");
        m_appType = module->getAttributeValue("type");
        m_appWorkingDir = module->getAttributeValue("working_dir");
        m_appCategory = module->getAttributeValue("category");

        m_appIcon = module->getAttributeValue("icon");
        m_showAppConsole = module->getAttributeValueAsBool("show_console");
        std::string args = module->getAttributeValue("args");
        std::vector<std::string> argPairs = StringUtils::split(args,";;;");
        for(const std::string& argPair : argPairs)
        {
            std::vector<std::string> argValues = StringUtils::split(argPair,"%%%");
            if (argValues.size()>1)
            {
                std::string flag,arg;
                if (StringUtils::trimmed(argValues[0]).size()>0)
                {
                    flag = (argValues[0]);
                }

                if (StringUtils::trimmed(argValues[1]).size()>0)
                {
                    arg = (argValues[1]);
                }
                addApplicationArg(flag,arg);
            }
        }
        m_appDefPath = filePath;
    }
    else
    {
        throw FileNotFoundException(EXCEPTION_TAG_LINE+"Could not parse file at \""+filePath+"\"");
    }
}

void RStatsModuleProperties::saveApplicationConfig()
{
    saveApplicationConfig(m_appDefPath);
}

void RStatsModuleProperties::saveApplicationConfig(const std::string &filePath)
{
    std::ofstream out(filePath.c_str());
    if (out.is_open())
    {
        XMLStreamWriter xml(out);
        xml.writeStartDocument();
        xml.writeStartElement("module");
        xml.writeAttribute("name",m_appName);
        xml.writeAttribute("category",m_appCategory);
        xml.writeAttribute("path",m_appPath);
        xml.writeAttribute("script_path",m_appScriptPath);
        xml.writeAttribute("type",m_appType);
        xml.writeAttribute("working_dir",m_appType);
        xml.writeAttribute("icon",m_appIcon);
        xml.writeAttribute("show_console", (m_showAppConsole ? "TRUE" : "FALSE"));
        std::string argStr;
        for (const std::pair<std::string,std::string>& arg : m_args)
        {
            argStr+=arg.first+"%%%"+arg.second+";;;";
        }
        xml.writeLastAttributeAndCloseTag("args",argStr);
        m_appDefPath = filePath;
    }
}

void RStatsModuleProperties::setType(const std::string &value)
{
    m_appType=value;
}

void RStatsModuleProperties::setName(const std::string & value)
{
    m_appName=value;
}

void RStatsModuleProperties::setWorkingDir(const std::string & value)
{
    m_appWorkingDir=value;
}

void RStatsModuleProperties::setPath(const std::string & value)
{
    m_appPath=value;
}

void RStatsModuleProperties::setCategory(const std::string & value)
{
    m_appCategory=value;
}

void RStatsModuleProperties::setArgs(const std::vector<std::pair<std::string,std::string> > & value)
{
    m_args=value;
}

void RStatsModuleProperties::generateApplicationCommand(std::string& commandOut)
{
    std::ostringstream command;
    command << m_appScriptPath<<" "<<m_appPath<<" ";
    for (const auto& it : m_args)
    {
        if (it.first.size())
        {
            command << it.first<<" ";
        }
        if (it.second.size())
        {
            command <<"\""<<it.second<<"\" ";
        }
    }
    commandOut = command.str();
}

const std::string &RStatsModuleProperties::getType() const
{
    return m_appType;
}

const std::string &RStatsModuleProperties::getName() const
{
    return m_appName;
}

const std::string &RStatsModuleProperties::getWorkingDir() const
{
    return m_appWorkingDir;
}

const std::string &RStatsModuleProperties::getPath() const
{
    return m_appPath;
}

const std::string &RStatsModuleProperties::getCategory() const
{
    return m_appCategory;
}

const std::string &RStatsModuleProperties::getDefinitionPath() const
{
    return m_appDefPath;
}

const std::vector<std::pair<std::string,std::string> > &RStatsModuleProperties::getArgs() const
{
    return m_args;
}

void RStatsModuleProperties::setDefinitionPath(const std::string &path)
{
    m_appDefPath = path;
}

void RStatsModuleProperties::addApplicationArg(const std::string &flag,
                                               const std::string &argument)
{
    m_args.push_back(std::make_pair(flag,argument));
}

void RStatsModuleProperties::clearApplicationArgs()
{
    m_args.clear();
}

void RStatsModuleProperties::setScriptPath(const std::string &scriptFilePath)
{
    m_appScriptPath = scriptFilePath;
}

const std::string &RStatsModuleProperties::getScriptPath() const
{
    return m_appScriptPath;
}

void RStatsModuleProperties::addApplicationFlag(const std::string &flag)
{
    m_args.push_back(std::make_pair(flag,""));
}

void RStatsModuleProperties::setIcon(const std::string &appIcon)
{
    m_appIcon = appIcon;
}

std::string RStatsModuleProperties::getIcon() const
{
    return m_appIcon;
}

bool RStatsModuleProperties::isApplicationConsoleShown() const
{
    return m_showAppConsole;
}
}}}//end namespace


